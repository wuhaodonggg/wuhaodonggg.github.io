<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试页</title>
      <link href="/2024/05/26/%E6%B5%8B%E8%AF%95%E9%A1%B5/"/>
      <url>/2024/05/26/%E6%B5%8B%E8%AF%95%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/26/hello-world/"/>
      <url>/2024/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2024/05/14/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/05/14/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是spring？"><a href="#什么是spring？" class="headerlink" title="什么是spring？"></a>什么是spring？</h2><p>Spring是Java企业级应用的开源开发框架。</p><p>Spring框架目标是简化Java企业级应用开发，通过POJO为基础的编程模型促进良好的编程习惯。</p><h2 id="使用Spring框架的好处有哪些？"><a href="#使用Spring框架的好处有哪些？" class="headerlink" title="使用Spring框架的好处有哪些？"></a>使用Spring框架的好处有哪些？</h2><ul><li>轻量：Spring是轻量的，基本版本大约2mb</li><li>控制反转：Spring通过控制反转实现了松散耦合，对象们给出他们的依赖，而不是创建或查找依赖的对象们</li><li>面向切面编程（AOP）：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li><li>容器：Spring包含并管理应用中对象的生命周期和配置</li><li>MVC框架：Spring的Web框架是个精心设计的框架，是Web框架的一个很好的替代品</li><li>事务管理：Spring提供一个可持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li><li>异常处理：Sping提供方便的API把具体技术相关的异常转化为一致的unchecked异常</li></ul><h2 id="Spring由哪些模块组成？"><a href="#Spring由哪些模块组成？" class="headerlink" title="Spring由哪些模块组成？"></a>Spring由哪些模块组成？</h2><ul><li>Core module</li><li>Bean module</li><li>Context module</li><li>Expression Language module</li><li>JDBC module</li><li>ORM module</li><li>OXM module</li><li>Java Messaging Service(JMS) module</li><li>Transaction module</li><li>Web module</li><li>Web-Servlet module</li><li>Web-Struts module</li><li>Web-Portlet module</li></ul><h2 id="核心容器（应用上下文）模块"><a href="#核心容器（应用上下文）模块" class="headerlink" title="核心容器（应用上下文）模块"></a>核心容器（应用上下文）模块</h2><p>基本的Spring模块，提供Spring框架的基础功能，BeanFactory是任何以Spring为基础的应用核心。</p><p>Sping框架建立在此模块之上，它使Spring成为一个容器。</p><h2 id="什么是Spring-IOC容器？"><a href="#什么是Spring-IOC容器？" class="headerlink" title="什么是Spring IOC容器？"></a>什么是Spring IOC容器？</h2><p>Spring IOC容器负责创建对象，管理对象，通过依赖注入DI，装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h2 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h2><p>IOC或依赖注入把应用的代码量降到最低。</p><p>它使应用容易测试，单元测试不需要单例和JNDI查找机制，</p><p>最小的代价和最小的侵入性使松散耦合得以实现。</p><p>IOC容器支持加载服务时的饿汉式初始化和懒加载。</p><h2 id="Application-Context通常的实现是什么？"><a href="#Application-Context通常的实现是什么？" class="headerlink" title="Application Context通常的实现是什么？"></a>Application Context通常的实现是什么？</h2><ul><li>FileSystemXmlApplicationContext ：此容器从一个XML 文件中加载beans<br>的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个XML 文件中加载beans<br>的定义，这里，你需要正确设置classpath 因为这个容器将在classpath 里找<br>bean 配置。 </li><li>WebXmlApplicationContext：此容器加载一个XML 文件，此文件定义了一个<br>WEB 应用的所有bean。</li></ul><h2 id="Bean-Factory和Applicaiton-Contexts有什么区别"><a href="#Bean-Factory和Applicaiton-Contexts有什么区别" class="headerlink" title="Bean Factory和Applicaiton Contexts有什么区别"></a>Bean Factory和Applicaiton Contexts有什么区别</h2><p>Applicaiton Contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），他们可以向注册为监听器的bean发布事件。</p><p>另外在容器或容器内的对象上执行的哪些不得由bean工厂以程序化处理的操作，可以在Applicaiton Contexts中以声明的方式处理。</p><p>Application Contexts实现了MessageSource接口，该接口的实现方式以可插拔的方式提供获取本地化消息的方法。</p><h2 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h2><p>依赖注入是IOC的一个方面，是个通常的概念，它有多种解释。</p><p>这概念是说你不需要创建对象，而至需要描述它如何被创建。</p><p>你不在代码里直接组装组件和服务，但是要在配置文件中描述哪些组件需要哪些服务，之后一个容器负责把他们组装起来。</p><h2 id="有哪些不同类型的IOC依赖注入方式？"><a href="#有哪些不同类型的IOC依赖注入方式？" class="headerlink" title="有哪些不同类型的IOC依赖注入方式？"></a>有哪些不同类型的IOC依赖注入方式？</h2><ul><li>构造器注入：构造器依赖注入需要通过容器触发一个类的构造器来实现，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li>Setter方法注入：Setter‘方法注入是容器通过调用午餐构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li></ul><h2 id="Autowired和Resource关键字的区别？"><a href="#Autowired和Resource关键字的区别？" class="headerlink" title="Autowired和Resource关键字的区别？"></a>Autowired和Resource关键字的区别？</h2><p>@Resource和@Autowired都是做bean的注入时使用。</p><p>@Resource并不是Spring的注解，他的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p><strong>共同点：</strong>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p><strong>不同点：</strong></p><ul><li><p>@Autowired为Spring提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="comment">// 下面两种@Autowired只要使用一种即可</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的方法上</span></span><br><span class="line"><span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2024/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2024/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件</title>
      <link href="/2024/05/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2024/05/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
      <url>/2023/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL是一种开源的关系型数据库管理系统（RDBMS）</p><h2 id="MySQL-的逻辑架构了解吗？"><a href="#MySQL-的逻辑架构了解吗？" class="headerlink" title="MySQL 的逻辑架构了解吗？"></a>MySQL 的逻辑架构了解吗？</h2><ul><li>第一层是服务器层，主要提供连接处理、授权认证、安全等功能。</li><li>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。</li><li>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</li></ul><p><img src="/2023/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/c929f07ee531f68c08139704001d4ff4.jpg" alt="逻辑架构"></p><h2 id="谈一谈-MySQL-的读写锁"><a href="#谈一谈-MySQL-的读写锁" class="headerlink" title="谈一谈 MySQL 的读写锁"></a>谈一谈 MySQL 的读写锁</h2><p>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p><p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。</p><h2 id="MySQL-的锁策略有什么？"><a href="#MySQL-的锁策略有什么？" class="headerlink" title="MySQL 的锁策略有什么？"></a>MySQL 的锁策略有什么？</h2><p><strong>表锁</strong>是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。</p><p><strong>行锁</strong>可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。</p><h2 id="数据库死锁如何解决？"><a href="#数据库死锁如何解决？" class="headerlink" title="数据库死锁如何解决？"></a>数据库死锁如何解决？</h2><p>当两个及以上的事务，双方都在等待对方释放已经持有的锁或因为加锁顺序不一致造成循环等待锁资源，就会出现“死锁”。常见的报错信息为 <code>Deadlock found when trying to get lock...</code>。</p><p>举例来说 A 事务持有 X1 锁 ，申请 X2 锁，B事务持有 X2 锁，申请 X1 锁。A 和 B 事务持有锁并且申请对方持有的锁进入循环等待，就造成了死锁。</p><p><img src="/2023/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/AFE68E8D486A19B26B7D54B76BD8A6DC.jpg" alt="死锁"></p><p>如上图，是右侧的四辆汽车资源请求产生了回路现象，即死循环，导致了死锁。</p><p>从死锁的定义来看，MySQL 出现死锁的几个要素为：</p><ol><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ol><h3 id="InnoDB-锁类型"><a href="#InnoDB-锁类型" class="headerlink" title="InnoDB 锁类型"></a>InnoDB 锁类型</h3><p>为了分析死锁，我们有必要对 InnoDB 的锁类型有一个了解。</p><p><img src="/2023/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/30A30663CBD02B937C956934D78D6F63.jpg" alt="锁类型"></p><p>MySQL InnoDB 引擎实现了标准的<code>行级别锁：共享锁( S lock ) 和排他锁 ( X lock )</code></p><blockquote><ol><li>不同事务可以同时对同一行记录加 S 锁。</li><li>如果一个事务对某一行记录加 X 锁，其他事务就不能加 S 锁或者 X 锁，从而导致锁等待。</li></ol></blockquote><p>如果事务 T1 持有行 r 的 S 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理:</p><blockquote><ol><li>T2 请求 S 锁立即被允许，结果 T1 T2 都持有 r 行的 S 锁</li><li>T2 请求 X 锁不能被立即允许</li></ol></blockquote><p>如果 T1 持有 r 的 X 锁，那么 T2 请求 r 的 X、S 锁都不能被立即允许，T2 必须等待 T1 释放 X 锁才可以，因为 X 锁与任何的锁都不兼容。共享锁和排他锁的兼容性如下所示：</p><p><img src="/2023/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/924A7088376A35A820369F44E82753E7.jpg" alt="兼容性"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>重试机制（Retry Mechanism）：<ul><li>当检测到死锁时，可以设置一个重试机制，让事务在一段时间后重新尝试执行。这种方法可能会多次重试，直到成功或达到最大尝试次数。</li><li>重试时可以释放已经获取的资源，重新请求锁，以避免死锁再次发生。</li></ul></li><li>超时设置（Timeouts）：<ul><li>可以为每个事务设置一个超时时间，在该时间内如果无法获取所需的锁，事务将被中止。</li><li>超时设置可以防止事务无限期地等待锁，但可能会导致事务被中止，需要谨慎设置超时值。</li></ul></li><li>死锁检测和回滚（Deadlock Detection and Rollback）：<ul><li>数据库系统可以周期性地检测死锁的发生，一旦检测到死锁，系统会选择一个或多个事务进行回滚，以解除死锁。</li><li>通常，系统会选择那些最少影响的事务进行回滚，以最小化数据丢失。</li></ul></li><li>锁粒度调整（Lock Granularity Adjustment）：<ul><li>调整事务中锁的粒度，以减少死锁的可能性。例如，将表级锁改为行级锁，或者反之，根据具体情况来选择最合适的锁粒度。</li></ul></li><li>锁等待图（Lock Wait Graph）：<ul><li>使用锁等待图来分析和监控锁的等待关系，以帮助识别和解决死锁问题。</li><li>一旦发现死锁，可以通过中断一个或多个事务来打破死锁。</li></ul></li><li>事务顺序化（Transaction Serialization）：<ul><li>将一部分并发操作转换成串行执行，以避免死锁。这可能会降低性能，但可以确保数据的一致性。</li></ul></li><li>设计良好的应用程序：<ul><li>在应用程序级别，可以通过设计良好的事务管理和锁定策略来减少死锁的发生。确保事务按照相同的顺序请求锁，可以减少死锁的概率。</li></ul></li></ul><h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么?"></a>事务是什么?</h2><p>事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。</p><h2 id="事务有什么特性？"><a href="#事务有什么特性？" class="headerlink" title="事务有什么特性？"></a>事务有什么特性？</h2><h3 id="原子性-atomicity"><a href="#原子性-atomicity" class="headerlink" title="原子性 atomicity"></a><strong>原子性 atomicity</strong></h3><p>一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。</p><h3 id="一致性-consistency"><a href="#一致性-consistency" class="headerlink" title="一致性 consistency"></a><strong>一致性 consistency</strong></h3><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p><h3 id="隔离性-isolation"><a href="#隔离性-isolation" class="headerlink" title="隔离性 isolation"></a><strong>隔离性 isolation</strong></h3><p>针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><h3 id="持久性-durability"><a href="#持久性-durability" class="headerlink" title="持久性 durability"></a><strong>持久性 durability</strong></h3><p>一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</p><h2 id="MySQL-的隔离级别有哪些？"><a href="#MySQL-的隔离级别有哪些？" class="headerlink" title="MySQL 的隔离级别有哪些？"></a>MySQL 的隔离级别有哪些？</h2><h3 id="未提交读-READ-UNCOMMITTED"><a href="#未提交读-READ-UNCOMMITTED" class="headerlink" title="未提交读 READ UNCOMMITTED"></a><strong>未提交读 READ UNCOMMITTED</strong></h3><p>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有比其他级别好很多，很少使用。</p><h3 id="提交读-READ-COMMITTED"><a href="#提交读-READ-COMMITTED" class="headerlink" title="提交读 READ COMMITTED"></a><strong>提交读 READ COMMITTED</strong></h3><p>多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能”看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。</p><h3 id="可重复读-REPEATABLE-READ（MySQL默认的隔离级别）"><a href="#可重复读-REPEATABLE-READ（MySQL默认的隔离级别）" class="headerlink" title="可重复读 REPEATABLE READ（MySQL默认的隔离级别）"></a><strong>可重复读 REPEATABLE READ</strong>（MySQL默认的隔离级别）</h3><p>可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。InnoDB 存储引擎通过多版本并发控制MVCC 解决幻读的问题。</p><h3 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化 SERIALIZABLE"></a><strong>可串行化 SERIALIZABLE</strong></h3><p>最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。</p><h2 id="MVCC-是什么？"><a href="#MVCC-是什么？" class="headerlink" title="MVCC 是什么？"></a>MVCC 是什么？</h2><p>MVCC 是多版本并发控制，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p>InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p>MVCC 只能在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作，因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</p><h2 id="谈一谈-InnoDB"><a href="#谈一谈-InnoDB" class="headerlink" title="谈一谈 InnoDB"></a>谈一谈 InnoDB</h2><p>InnoDB 是 MySQL 的默认事务型引擎，用来处理大量短期事务。InnoDB 的性能和自动崩溃恢复特性使得它在非事务型存储需求中也很流行，除非有特别原因否则应该优先考虑 InnoDB。</p><p>InnoDB 的数据存储在表空间中，表空间由一系列数据文件组成。MySQL4.1 后 InnoDB 可以将每个表的数据和索引放在单独的文件中。</p><p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 <code>REPEATABLE READ</code>，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p><p>InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键很大的话其他所有索引都会很大，因此如果表上索引较多的话主键应当尽可能小。</p><p>InnoDB 的存储格式是平立的，可以将数据和索引文件从一个平台复制到另一个平台。</p><p>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><h2 id="谈一谈-MyISAM"><a href="#谈一谈-MyISAM" class="headerlink" title="谈一谈 MyISAM"></a>谈一谈 MyISAM</h2><p>MySQL5.1及之前，MyISAM 是默认存储引擎，MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行锁，最大的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复操作的情况仍然可以使用 MyISAM。</p><p>MyISAM 将表存储在数据文件和索引文件中，分别以 <code>.MYD</code> 和 <code>.MYI</code> 作为扩展名。MyISAM 表可以包含动态或者静态行，MySQL 会根据表的定义决定行格式。MyISAM 表可以存储的行记录数一般受限于可用磁盘空间或者操作系统中单个文件的最大尺寸。</p><p>MyISAM 对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也支持并发往表中插入新的记录。</p><p>对于MyISAM 表，MySQL 可以手动或自动执行检查和修复操作，这里的修复和事务恢复以及崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，而且修复操作很慢。</p><p>对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前 500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</p><p>MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。MyISAM 最典型的性能问题还是表锁问题，如果所有的查询长期处于 Locked 状态，那么原因毫无疑问就是表锁。</p><h2 id="谈一谈-Memory"><a href="#谈一谈-Memory" class="headerlink" title="谈一谈 Memory"></a>谈一谈 Memory</h2><p>如果需要快速访问数据且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少要比 MyISAM 表快一个数量级，因为所有数据都保存在内存，不需要磁盘 IO，Memory 表的结构在重启后会保留，但数据会丢失。</p><p>Memory 表适合的场景：查找或者映射表、缓存周期性聚合数据的结果、保存数据分析中产生的中间数据。</p><p>Memory 表支持哈希索引，因此查找速度极快。虽然速度很快但还是无法取代传统的基于磁盘的表，Memory 表使用表级锁，因此并发写入的性能较低。它不支持 BLOB 和 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费。</p><p>如果 MySQL 在执行查询的过程中需要使用临时表来保持中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了Memory 表的限制，或者含有 BLOB 或 TEXT 字段，临时表会转换成 MyISAM 表。</p><h2 id="查询执行流程是什么？"><a href="#查询执行流程是什么？" class="headerlink" title="查询执行流程是什么？"></a>查询执行流程是什么？</h2><p>简单来说分为五步：</p><ul><li>① 客户端发送一条查询给服务器。</li><li>② 服务器先检查查询缓存，如果命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。</li><li>③ 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。</li><li>④ MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li><li>⑤ 将结果返回给客户端。</li></ul><h2 id="VARCHAR-和-CHAR-的区别？"><a href="#VARCHAR-和-CHAR-的区别？" class="headerlink" title="VARCHAR 和 CHAR 的区别？"></a>VARCHAR 和 CHAR 的区别？</h2><p><strong>VARCHAR</strong> 用于存储可变字符串，是最常见的字符串数据类型。它比 CHAR 更节省空间，因为它仅使用必要的空间。VARCHAR 需要 1 或 2 个额外字节记录字符串长度，如果列的最大长度不大于 255 字节则只需要 1 字节。VARCHAR 不会删除末尾空格。</p><p>VARCHAR 适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。</p><p><strong>CHAR</strong> 是定长的，根据定义的字符串长度分配足够的空间。CHAR 会删除末尾空格。</p><p>CHAR 适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。</p><h2 id="DATETIME-和-TIMESTAMP-的区别？"><a href="#DATETIME-和-TIMESTAMP-的区别？" class="headerlink" title="DATETIME 和 TIMESTAMP 的区别？"></a>DATETIME 和 TIMESTAMP 的区别？</h2><p><strong>DATETIME</strong> 能保存大范围的值，从 1001~9999 年，精度为秒。把日期和时间封装到了一个整数中，与时区无关，使用 8 字节存储空间。</p><p><strong>TIMESTAMP</strong> 和 UNIX 时间戳相同，只使用 4 字节的存储空间，范围比 DATETIME 小得多，只能表示 1970 ~2038 年，并且依赖于时区。</p><h2 id="索引有什么作用？"><a href="#索引有什么作用？" class="headerlink" title="索引有什么作用？"></a>索引有什么作用？</h2><p>索引也叫键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。</p><p>索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免排序和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。</p><p>在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能使用索引的最左前缀。</p><h2 id="索引失效的情况有哪些？"><a href="#索引失效的情况有哪些？" class="headerlink" title="索引失效的情况有哪些？"></a>索引失效的情况有哪些？</h2><ol><li><strong>使用不等于操作符（!=）</strong>：在MySQL中，不等于操作符（!=）或非等于操作符（&lt;&gt;）会使索引失效。</li><li><strong>使用LIKE操作符</strong>：在LIKE操作符的查询条件中，如果使用了通配符（%）以外的其他字符，MySQL将无法使用索引。</li><li><strong>使用OR操作符</strong>：在WHERE子句中，如果使用了OR操作符连接多个条件，且这些条件中的列没有形成联合索引，那么索引将可能失效。</li><li><strong>使用函数或表达式</strong>：在查询中，如果对索引列使用了函数或表达式，那么MySQL将无法使用该列的索引。</li><li><strong>数据类型不一致</strong>：如果查询中的数据类型与表中的数据类型不一致，可能会导致索引失效。</li><li><strong>NULL值</strong>：如果索引列包含NULL值，并且查询没有明确处理NULL值，那么索引可能不会正常工作。</li><li><strong>索引碎片过多</strong>：如果数据库中的数据发生了大量的增删改操作，可能会导致索引碎片过多，这可能会影响查询性能，甚至可能导致索引失效。</li><li><strong>查询优化器的选择</strong>：有时候，即使索引可用，MySQL的查询优化器可能会根据其判断选择全表扫描而非使用索引。</li><li><strong>未及时更新索引</strong>：在并发插入、更新、删除操作的场景下，可能会出现刚更新的数据未及时更新到索引中的情况。</li><li><strong>锁竞争和并发控制</strong>：在高并发的场景下，如果对索引的锁竞争过大，可能会导致索引的并发控制能力下降，进而影响查询性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关系型数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2023/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式（Strategy Pattern）也被称为政策模式（Policy Pattern），是在 GoF 23 种设计模式中定义了的行为型模式。</p><p>策略模式 是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，使得它们可以互换，被封装起来的算法具有独立性外部不可改变其特性。</p><p>策略模式 在实际的项目开发中，这个模式也比较常用。最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><ul><li>环境类（StrategyContext）：策略上下文对象，维护指向具体策略的引用，通过策略接口 Strategy 与对象进行沟通。</li><li>抽象策略类（Strategy）：策略接口，定义统一的策略入口方法，留给具体策略类实现，且供 StrategyContext 调用。</li><li>具体策略类（ConcreteStrategy）：具体的策略类，实现 Strategy，提供各种不同的算法。</li></ul><p><img src="/2023/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/00b734920ee8d3fc72cc539cdda2d890.png" alt="类图"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>策略模式符合开闭原则；</li><li>避免了使用多重条件语句。如 if…else…语句、switch语句；</li><li>使用策略模式可以提高算法的保密性和安全性。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>客户端必须知道所有策略，并自行决定使用那种策略；</li><li>代码中会产生非常多的策略，增加维护难度；</li><li>如果业务逻辑不是很复杂，强行使用策略模式会增加程序的复杂度。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> <strong>Context 环境类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个具体策略的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy 具体策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInterface</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        strategy.interfaceStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Strategy 抽象策略类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceStrategy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ConcreteStrategy 具体策略类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟业务参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">parameter</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行使用A策略</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        context1.contextInterface();</span><br><span class="line">        <span class="comment">// 执行使用B策略</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">        context2.contextInterface();</span><br><span class="line">        <span class="comment">// 执行使用C策略</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">        context3.contextInterface();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式的应用（Comparator-中的策略模式）"><a href="#策略模式的应用（Comparator-中的策略模式）" class="headerlink" title="策略模式的应用（Comparator 中的策略模式）"></a>策略模式的应用（Comparator 中的策略模式）</h2><p>JDK 中最常见的策略模式，就是 Comparator 中的策略模式。在 Arrays 类中有一个 sort() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays 就是一个环境角色类，这个 sort 方法可以传一个新策略让 Arrays 根据这个策略来进行排序。如下测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Integer[] data = &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 实现降序排序</span></span><br><span class="line">        Arrays.sort(data, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(data)); <span class="comment">//[12, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在调用 Arrays 的 sort 方法时，第二个参数传递的是 Comparator 接口的子实现类对象。所以 Comparator 充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays 类的 sort 方法到底有没有使用 Comparator 子实现类中的 compare() 方法吗？让我们继续查看 TimSort 类的 sort() 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimSort</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, <span class="type">int</span> lo, <span class="type">int</span> hi, Comparator&lt;? <span class="built_in">super</span> T&gt; c,</span></span><br><span class="line"><span class="params">                         T[] work, <span class="type">int</span> workBase, <span class="type">int</span> workLen)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="literal">null</span> &amp;&amp; a != <span class="literal">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nRemaining</span>  <span class="operator">=</span> hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a &quot;mini-TimSort&quot; with no merges</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">initRunLen</span> <span class="operator">=</span> countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="type">int</span> lo, <span class="type">int</span> hi,Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="type">int</span> <span class="variable">runHi</span> <span class="operator">=</span> lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">            reverseRange(a, lo, runHi);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中最终会跑到 countRunAndMakeAscending() 这个方法中。我们可以看见，只用了 compare 方法，所以在调用 Arrays.sort 方法只传具体 compare 重写方法的类对象就行，这也是 Comparator 接口中必须要子类实现的一个方法。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。</p><blockquote><p>属于创建模式，</p><p>单例类只能有一个实例。</p><p>单例类必须自己创建自己的唯一实例。</p><p>单例类必须给所有其他对象提供这一实例。</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li>一个班级只有一个班主任。</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>要求生产唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li></ul><blockquote><p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>SingleObject</em> 类。<em>SingleObject</em> 类有它的私有构造函数和本身的一个静态实例。</p><p><em>SingleObject</em> 类提供了一个静态方法，供外界获取它的静态实例。<em>SingletonPatternDemo</em> 类使用 <em>SingleObject</em> 类来获取 <em>SingleObject</em> 对象。</p><p><img src="/2023/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/62576915-36E0-4B67-B078-704699CA980A.jpg" alt="类图"></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个 Singleton 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleObject</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleObject</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleObject</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">SingleObject</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>从 singleton 类获取唯一的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//不合法的构造函数</span></span><br><span class="line">      <span class="comment">//编译时错误：构造函数 SingleObject() 是不可见的</span></span><br><span class="line">      <span class="comment">//SingleObject object = new SingleObject();</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">      <span class="type">SingleObject</span> <span class="variable">object</span> <span class="operator">=</span> SingleObject.getInstance();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//显示消息</span></span><br><span class="line">      object.showMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>执行程序，输出结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><h3 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h3><div class="table-container"><table><thead><tr><th><strong>是否 Lazy 初始化</strong></th><th>是</th></tr></thead><tbody><tr><td><strong>是否多线程安全</strong></td><td><strong>否</strong></td></tr><tr><td><strong>实现难度</strong></td><td><strong>易</strong></td></tr></tbody></table></div><blockquote><p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><div class="table-container"><table><thead><tr><th><strong>是否 Lazy 初始化</strong></th><th>是</th></tr></thead><tbody><tr><td><strong>是否多线程安全</strong></td><td><strong>是</strong></td></tr><tr><td><strong>实现难度</strong></td><td><strong>易</strong></td></tr></tbody></table></div><blockquote><p>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><ul><li></li><li><p>优点：第一次调用才初始化，避免内存浪费。</p></li><li>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</li></ul><p>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p></blockquote><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><div class="table-container"><table><thead><tr><th><strong>是否 Lazy 初始化</strong></th><th>否</th></tr></thead><tbody><tr><td><strong>是否多线程安全</strong></td><td><strong>是</strong></td></tr><tr><td><strong>实现难度</strong></td><td><strong>易</strong></td></tr></tbody></table></div><blockquote><p>这种方式比较常用，但容易产生垃圾对象。</p><ul><li>优点：没有加锁，执行效率会提高。</li><li>缺点：类加载时就初始化，浪费内存。</li></ul><p>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p></blockquote><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h3><div class="table-container"><table><thead><tr><th><strong>是否 Lazy 初始化</strong></th><th>是</th></tr></thead><tbody><tr><td><strong>是否多线程安全</strong></td><td><strong>是</strong></td></tr><tr><td><strong>实现难度</strong></td><td><strong>较复杂</strong></td></tr><tr><td><strong>JDK 版本</strong></td><td><strong>JDK1.5</strong> <strong>起</strong></td></tr></tbody></table></div><blockquote><p>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p></blockquote><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h3><div class="table-container"><table><thead><tr><th><strong>是否 Lazy 初始化</strong></th><th>是</th></tr></thead><tbody><tr><td><strong>是否多线程安全</strong></td><td><strong>是</strong></td></tr><tr><td><strong>实现难度</strong></td><td><strong>一般</strong></td></tr></tbody></table></div><blockquote><p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p></blockquote><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><div class="table-container"><table><thead><tr><th><strong>是否 Lazy 初始化</strong></th><th>否</th></tr></thead><tbody><tr><td><strong>是否多线程安全</strong></td><td><strong>是</strong></td></tr><tr><td><strong>实现难度</strong></td><td><strong>易</strong></td></tr><tr><td><strong>JDK 版本</strong></td><td><strong>JDK1.5</strong> <strong>起</strong></td></tr></tbody></table></div><blockquote><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p></blockquote><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a><strong>经验之谈</strong></h2><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2023/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>观察者模式(Observer Pattern)</strong>： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><blockquote><ul><li>微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是『被观察者』，而用户就是『观察者』</li><li>气象站可以将每天预测到的温度、湿度、气压等以公告的形式发布给各种第三方网站，如果天气数据有更新，要能够实时的通知给第三方，这里的气象局就是『被观察者』，第三方网站就是『观察者』</li><li>MVC 模式中的模型与视图的关系也属于观察与被观察</li></ul></blockquote><p><img src="/2023/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/1.jpg" alt="调用关系"></p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li><strong>Subject（目标）</strong>：被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的Vector 容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</li><li><strong>ConcreteSubject（具体目标）</strong>：具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</li><li><strong>Observer（观察者）</strong>：观察者将对观察目标的改变做出反应，观察者一般定义为<strong>接口</strong>，该接口声明了更新数据的方法 <code>update()</code>，因此又称为<strong>抽象观察者</strong>。</li><li><strong>ConcreteObserver（具体观察者）</strong>：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update()方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2023/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/2.jpg" alt="类图"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>1、定义观察者接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、定义被观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs = <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer obs)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obs.add(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delObserver</span><span class="params">(Observer obs)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obs.remove(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer o: obs)&#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、具体的被观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被观察者事件发生改变&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、具体的被观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者1收到信息，并进行处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者2收到信息，并进行处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver1</span>()); <span class="comment">//添加观察者1</span></span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver2</span>()); <span class="comment">//添加观察者2</span></span><br><span class="line">        sub.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被观察者事件发生改变</span><br><span class="line">观察者1收到信息，并进行处理</span><br><span class="line">观察者2收到信息，并进行处理</span><br></pre></td></tr></table></figure><p>通过运行结果可以看到，我们只调用了 <code>Subject</code> 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 <code>Subject</code> 类中关联一下 <code>Observer</code> 类，并且在 <code>doSomething()</code> 方法中遍历一下 <code>Observer</code> 的 <code>update()</code> 方法就行了。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</li><li>目标与观察者之间建立了一套触发机制</li><li>支持广播通信</li><li>符合“开闭原则”的要求</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li></ul><h2 id="JDK中的观察者模式"><a href="#JDK中的观察者模式" class="headerlink" title="JDK中的观察者模式"></a>JDK中的观察者模式</h2><p>观察者模式在 Java 语言中的地位非常重要。在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持（可以去查看下源码，写的比较严谨）。但是，在 Java9 被弃用了。</p><h2 id="Spring中的观察者模式"><a href="#Spring中的观察者模式" class="headerlink" title="Spring中的观察者模式"></a>Spring中的观察者模式</h2><h4 id="1-事件（ApplicationEvent）"><a href="#1-事件（ApplicationEvent）" class="headerlink" title="1. 事件（ApplicationEvent）"></a><strong>1. 事件（ApplicationEvent）</strong></h4><p>ApplicationEvent 是所有事件对象的父类。ApplicationEvent 继承自 jdk 的 EventObject, 所有的事件都需要继承 ApplicationEvent, 并且通过 source 得到事件源。</p><p>下列描述了Spring提供的内置事件：</p><ul><li>ContextRefreshedEvent：事件发布在 ApplicationContext 初始化或刷新时（例如：通过在 ConfigurableApplicationContext 接口使用refresh()方法）。这里,“初始化”意味着所有 bean 加载，post-processor bean 被检测到并且激活,单例预先实例化，ApplicationContext 对象可以使用了。只要上下文没有关闭,可以触发多次刷新, ApplicationContext 提供了一种可选择的支持这种“热”刷新。例如：XmlWebApplicationContext 支持热刷新,但 GenericApplicationContext 并非如此。具体是在 AbstractApplicationContext 的 finishRefresh() 方法中。</li><li>ContextStartedEvent：事件发布在 ApplicationContext 开始使用 ConfigurableApplicationContext 接口 start() 方法。这里,“开始”意味着所有生命周期 bean 接收到一个明确的起始信号。通常,这个信号用于明确停止后重新启动,但它也可以用于启动组件没有被配置为自动运行（例如：组件还没有开始初始化）。</li><li>ContextStoppedEvent：事件发布在 ApplicationContext 停止时通过使用 ConfigurableApplicationContext 接口上的 stop() 方法。在这里,“停止”意味着所有生命周期bean接收一个显式的停止信号。停止上下文可以通过重新调用start()方法。</li><li>ContextClosedEvent：事件发布在 ApplicationContext 关闭时通过关闭 ConfigurableApplicationContext 接口()方法。这里,“封闭”意味着所有单例 bean 被摧毁。一个封闭的环境达到生命的终结。它不能刷新或重启。</li><li>RequestHandledEvent：一个特定的web事件告诉所有能处理HTTP请求的bean 。这个事件是在请求完成后发布的。这个事件只适用于使用 Spring 的 DispatcherServlet 的web应用程序。</li></ul><h4 id="2-事件监听（ApplicationListener）"><a href="#2-事件监听（ApplicationListener）" class="headerlink" title="2. 事件监听（ApplicationListener）"></a><strong>2. 事件监听（ApplicationListener）</strong></h4><p>ApplicationListener 事件监听器，也就是观察者。继承自 jdk 的 EventListener，该类中只有一个方法 onApplicationEvent。当监听的事件发生后该方法会被执行。</p><h4 id="3-事件发布（ApplicationContext）"><a href="#3-事件发布（ApplicationContext）" class="headerlink" title="3. 事件发布（ApplicationContext）"></a><strong>3. 事件发布（ApplicationContext）</strong></h4><p>ApplicationContext 是 Spring 中的核心容器，在事件监听中 ApplicationContext 可以作为事件的发布者，也就是事件源。因为 ApplicationContext 继承自 ApplicationEventPublisher。在 ApplicationEventPublisher 中定义了事件发布的方法 — publishEvent(Object event)</p><h4 id="4-事件管理（ApplicationEventMulticaster）"><a href="#4-事件管理（ApplicationEventMulticaster）" class="headerlink" title="4. 事件管理（ApplicationEventMulticaster）"></a><strong>4. 事件管理（ApplicationEventMulticaster）</strong></h4><p>ApplicationEventMulticaster 用于事件监听器的注册和事件的广播。监听器的注册就是通过它来实现的，它的作用是把 Applicationcontext 发布的 Event 广播给它的监听器列表。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试笔记</title>
      <link href="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="面试笔记"><a href="#面试笔记" class="headerlink" title="面试笔记"></a>面试笔记</h1><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><p>JavaSE：通常是指Java Standard Edition，Java标准版，就是一般Java程序的开发就可以(如桌面程序)，可以看作是JavaEE的子集。它允许开发和部署在桌面、服务器、嵌入式环境和实施环境中使用的Java应用程序。</p><p>JavaEE：Java Enterprise Edition，Java企业版，多用于企业级开发，包括web开发等等。是在JavaSE的基础上构建的，用来开发B/S架构软件，也就是开发企业级应用，所以称为企业版帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。</p><p>Java ME：为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME包括灵活的用户界面、健壮的安全模式、许多内置的网络协议以及对于动态下载的连网和离线应用程序的丰富支持。</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\bc8a163e7d5d4b7987a34fa7b56090datplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="img"></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>三种类型的异常</p><ul><li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><p>Java把异常当作对象来处理，并定义一个基类<code>java.lang.Throwable</code>作为所有异常的超类。</p><p>在Java API中已经定义了许多异常类，这些异常类分为两大类，<strong>错误<code>Error</code>和异常<code>Exception</code></strong>。</p><p>Java异常层次结构图如下图所示：</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\690102-20160728164909622-1770558953.png" alt="img"></p><p>所有异常类型都是内置类<code>Throwable</code>的子类，因而<code>Throwable</code>在异常类的层次结构的顶层。</p><p>接下来<code>Throwable</code>分成了两个不同的分支，<strong>一个分支是<code>Error</code>，它表示不希望被程序捕获或者是程序无法处理的错误</strong>。<strong>另一个分支是<code>Exception</code>，它表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常</strong>。其中异常类<code>Exception</code>又分为运行时异常(<code>RuntimeException</code>)和非运行时异常。</p><ul><li><strong><code>Error</code></strong>：<code>Error</code>类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，Java虚拟机运行错误（<code>Virtual MachineError</code>），当JVM不再有继续执行操作所需的内存资源时，将出现 <code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；</li><li><strong><code>Exception</code></strong>：在<code>Exception</code>分支中有一个重要的子类<code>RuntimeException</code>（运行时异常），该类型的异常自动为你所编写的程序定义<code>ArrayIndexOutOfBoundsException</code>（数组下标越界）、<code>NullPointerException</code>（空指针异常）、<code>ArithmeticException</code>（算术异常）、<code>MissingResourceException</code>（丢失资源）、<code>ClassNotFoundException</code>（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而<code>RuntimeException</code>之外的异常我们统称为非运行时异常，类型上属于<code>Exception</code>类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如<code>IOException</code>、<code>SQLException</code>等以及用户自定义的<code>Exception</code>异常，一般情况下不自定义检查异常。</li></ul><blockquote><p><code>Error</code>和<code>Exception</code>的区别：<code>Error</code>通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；<code>Exception</code>通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</p></blockquote><p>Java的异常处理本质上是<strong>抛出异常</strong>和<strong>捕获异常</strong>。</p><ul><li><strong><code>抛出异常</code></strong>：从当前环境中跳出，并把问题提交给上一级环境，这就是抛出异常时所发生的事情。抛出异常后，会有几件事随之发生。首先，是像创建普通的java对象一样将使用<code>new</code>在堆上创建一个异常对象；然后，当前的执行路径（已经无法继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序或者异常处理器，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。</li><li><strong><code>捕获异常</code></strong>：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li></ul><p>Java异常处理涉及到五个关键字，分别是：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code>。</p><p>　　• <strong>try</strong>     — 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>　　• <strong>catch</strong>  — 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>　　• <strong>finally</strong> — finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br>　　• <strong>throw</strong>  — 用于抛出异常。<br>　　• <strong>throws</strong> — 用在方法签名中，用于声明该方法可能抛出的异常。</p><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><h3 id="Lamdba表达式"><a href="#Lamdba表达式" class="headerlink" title="Lamdba表达式"></a>Lamdba表达式</h3><p>Lambda 是一个匿名函数，可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 的语言表达能力得到了提升。</p><p>举例： <code>(o1,o2) -&gt; Integer.compare(o1,o2);</code></p><ul><li><code>-&gt;</code> ：lambda 操作符 或 箭头操作符</li><li><code>-&gt;</code> 左边<code>(o1,o2)</code>：lambda 形参列表 （其实就是接口中的抽象方法的形参列表）</li><li><code>-&gt;</code> 右边<code>Integer.compare(o1,o2)</code>：lambda 体（其实就是重写的抽象方法的方法体）</li></ul><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul><li>只包含一个抽象方法的接口，称为函数式接口。</li><li>可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常（即：非运行时异常），那么该异常需要在目标接口的抽象方法上进行声明）。</li><li><p>可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。同时 <code>javadoc</code> 也会包含一条声明，说明这个接口是一个函数式接口。</p></li><li><p>Lambda 表达式的本质：作为函数式接口的实例</p></li><li>在 <code>java.util.function</code> 包下定义了Java 8的丰富的函数式接口</li></ul><h3 id="构造器和数组的引用"><a href="#构造器和数组的引用" class="headerlink" title="构造器和数组的引用"></a>构造器和数组的引用</h3><p>方法引用：类名 <code>::new</code></p><p>数组引用：数组类型 <code>[] :: new</code></p><h3 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h3><ul><li><code>Stream</code> 关注的是对数据的运算，与 <code>CPU</code> 打交道;集合关注的是数据的存储，与内存打交道;</li><li>Java 8 提供了一套 <code>api</code> ，使用这套 <code>api</code> 可以对内存中的数据进行过滤、排序、映射、归约等操作。类似于 <code>sql</code> 对数据库中表的相关操作。</li><li><code>Stream</code> 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<strong>“集合讲的是数据， Stream讲的是计算！”</strong></li></ul><p><strong>使用注意点:</strong></p><p>① <code>Stream</code> 自己不会存储元素。</p><p>② <code>Stream</code> 不会改变源对象。相反，他们会返回一个持有结果的新 <code>Stream</code>。</p><p>③ <code>Stream</code> 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\4c916340a0604848aca4fa54abc2f73etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image-20200507114714381"></p><p>Java 8的 <code>Collection</code> 接口被扩展，提供了两个获取流的方法：</p><ul><li><code>default Stream\&lt;E&gt; stream()</code> : 返回一个顺序流</li><li><code>default Stream\&lt;E&gt; parallelStream()</code> : 返回一个并行流</li></ul><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\b3bc20ab68ad4259aac42e24ca2e7c7ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image-20200507115721208"></p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\294f56a3a388432aa26d11e3bf28bb7etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image-20200507120245034"></p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\1054b625b0804861a79e43ec1a357318tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image-20200507120318120"></p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\b90ccac4359c41e89c26ecded974a97ctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image-20200507120339459"></p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\cad00ac44bc6419095ce1f9cbd586eeatplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image-20200507120628702"></p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\9046417d371c499b8988341cc31a9994tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="image-20200507120648175"></p><h3 id="Optional-类的使用"><a href="#Optional-类的使用" class="headerlink" title="Optional 类的使用"></a>Optional 类的使用</h3><p>为了解决 java 中的空指针问题而生！</p><p><code>Optional&lt;T&gt; 类(java.util.Optional)</code> 是一个容器类，它可以保存类型 <code>T</code> 的值，代表这个值存在。或者仅仅保存 <code>null</code>，表示这个值不存在。原来用 <code>null</code> 表示一个值不存在，现在 <code>Optional</code> 可以更好的表达这个概念。并且可以避免空指针异常。</p><p><code>Optional</code> 类提供了很多方法，可以不用再现实的进行空值检验。</p><ul><li><code>Optional.of(T t)</code> : 创建一个 <code>Optional</code> 实例，<code>t</code> 必须非空；</li><li><code>Optional.empty()</code> : 创建一个空的 <code>Optional</code> 实例</li><li><code>Optional.ofNullable(T t)</code>：<code>t</code> 可以为 <code>null</code></li></ul><h3 id="对反射的支持增强"><a href="#对反射的支持增强" class="headerlink" title="对反射的支持增强"></a>对反射的支持增强</h3><p>提高了创建对象、对象赋值和反射创建对象的时间</p><h3 id="Java-8-相对于-Java7增加了哪些新特性？"><a href="#Java-8-相对于-Java7增加了哪些新特性？" class="headerlink" title="Java 8 相对于 Java7增加了哪些新特性？"></a>Java 8 相对于 Java7增加了哪些新特性？</h3><p>Java 8 相对于 Java 7 带来了许多重要的新特性和改进。以下是 Java 8 中的一些主要新特性：</p><ol><li><strong>Lambda 表达式：</strong> Lambda 表达式是 Java 8 中最显著的新特性之一。它们允许您以更简洁的方式编写匿名函数，并更轻松地传递功能作为参数。这使得代码更具可读性和简洁性。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7中的匿名内部类</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8中使用Lambda表达式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li><p><strong>函数式接口：</strong> Java 8 引入了函数式接口概念，它们是只包含一个抽象方法的接口。这些接口可以用于Lambda表达式和方法引用。</p></li><li><p><strong>方法引用：</strong> 方法引用允许您使用已存在的方法来实现函数式接口。它们简化了代码，提高了可读性。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">names.forEach(System.out::println); <span class="comment">// 使用方法引用输出列表元素</span></span><br></pre></td></tr></table></figure><ol><li><strong>Stream API：</strong> Stream API 提供了一种强大的方式来处理集合数据。它允许您进行各种数据操作，如筛选、映射、聚合等，而无需显示使用循环。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>).mapToInt(Integer::intValue).sum();</span><br></pre></td></tr></table></figure><ol><li><strong>新的日期和时间 API：</strong> Java 8 引入了 java.time 包，提供了一套全新的日期和时间处理类。这个API更加灵活、强大，并解决了以前日期和时间API的一些问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">tomorrow</span> <span class="operator">=</span> now.plusDays(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li><strong>默认方法（Default Methods）：</strong> 接口中可以包含默认方法，这些方法可以在接口中提供默认的实现，而不需要实现类强制覆盖它们。这使得接口的升级变得更加容易。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">myDefaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Default method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>新的 JavaScript 引擎：</strong> Java 8 引入了 Nashorn JavaScript 引擎，允许在Java应用程序中嵌入JavaScript代码。</p></li><li><p><strong>新的并发特性：</strong> Java 8 引入了新的并发特性，如 CompletableFuture，用于更容易地编写异步和并发代码。</p></li></ol><p>这些是 Java 8 相对于 Java 7 的一些主要新特性。Java 8的引入极大地改进了Java编程语言的表达能力和开发效率，使其更适用于现代应用程序的构建。</p><h3 id="Java8对流操作相比于Java7对流操作提升在哪里"><a href="#Java8对流操作相比于Java7对流操作提升在哪里" class="headerlink" title="Java8对流操作相比于Java7对流操作提升在哪里"></a>Java8对流操作相比于Java7对流操作提升在哪里</h3><p>Java 8 引入了流（Stream）操作，相对于 Java 7 中的传统集合操作，提供了许多改进和优势。以下是 Java 8 对流操作相对于 Java 7 的传统集合操作的一些提升：</p><ol><li><p><strong>声明性编程：</strong> 流操作支持声明性编程，让您更关注“做什么”，而不是“如何做”。传统的集合操作通常需要编写显式的循环代码，而流操作允许您使用高级的操作符来表达数据处理需求。</p></li><li><p><strong>简洁性和可读性：</strong> 流操作使代码更简洁、可读性更高，因为它们通常可以在一行中表达复杂的数据处理逻辑。这降低了错误发生的机会，并提高了代码的可维护性。</p></li><li><p><strong>惰性求值：</strong> 流是惰性求值的，这意味着它们不会立即执行操作。相反，它们会等到真正需要结果时才执行操作。这种机制允许更有效地处理大量数据，减少了不必要的计算。</p></li><li><p><strong>并行处理：</strong> 流操作支持并行处理，可以自动利用多核处理器来提高性能。通过 <code>.parallel()</code> 方法，您可以轻松将流转换为并行流，从而并发处理数据。</p></li><li><p><strong>中间操作和终端操作：</strong> 流操作分为中间操作和终端操作。中间操作用于转换或筛选数据，但不会立即执行，而终端操作触发实际的计算。这使得可以灵活地组合多个中间操作来构建复杂的数据处理流水线。</p></li><li><p><strong>更多的操作：</strong> 流提供了丰富的操作，如 <code>filter</code>、<code>map</code>、<code>reduce</code>、<code>collect</code>、<code>forEach</code>、<code>flatMap</code> 等，使得您能够执行各种数据处理任务。</p></li><li><p><strong>不可变性：</strong> 流操作通常不会修改原始数据，而是生成一个新的流或集合，这有助于维护数据的不可变性。</p></li><li><p><strong>更容易的错误处理：</strong> 流操作的异常处理更加容易，您可以使用 <code>try-catch</code> 块或 <code>Optional</code> 类来处理可能的异常情况。</p></li></ol><p>总之，Java 8 引入的流操作相对于 Java 7 的传统集合操作提供了更高的抽象级别、更强的表达能力、更高的可读性、更好的性能和更多的操作。它们是现代Java编程中的一个强大工具，可以帮助开发人员更轻松地处理和转换数据集合。同时，流操作也更好地支持并行计算，使Java在多核处理器上运行时能够更好地利用硬件资源。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、 Execution engine(执行引擎)；<br>两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\image-20230913131619710-169458218189110.png" alt="image-20230913131619710"></p><ul><li>Class loader(类装载)：根据给定的全限定名类名(如： java.lang.Object)来装载class文件到Runtime data area中的method area。</li><li>Execution engine（执行引擎）：执行classes中的指令。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li></ul><p><strong>作用</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader） 再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\image-20230913133701142.png" alt="image-20230913133701142"></p><p>从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这 些.class文件加载到JVM<br>中。<br>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运<br>行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\image-20230913152710979-169459003344211.png" alt="image-20230913152710979"></p><h4 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h4><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的<br>区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java方法的，而本地方法栈是为虚拟机调用 Native方法服务的；</li><li>Java堆（Java Heap）：Java 虚拟机中内存大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><ul><li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址；</li><li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存；</li></ul><h4 id="堆栈区别"><a href="#堆栈区别" class="headerlink" title="堆栈区别"></a>堆栈区别</h4><ul><li>物理地址：堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代 （即新生代使用复制算法，老年代使用标记——压缩） 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</li><li>内存分别：堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般 堆大小远远大于栈。栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</li><li>存放的内容：堆存放的是对象的实例和数组。因此该区更关注的是数据的存储；栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</li><li>可见性：堆对于整个应用程序都是共享、可见的。栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</li></ul><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\image-20230913160532576.png" alt="image-20230913160532576"></p><p>下面是对象创建的主要流程:</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\image-20230913180112934-169459927481512.png" alt="image-20230913180112934"></p><p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有， 必须先执行相应的类加<br>载。类加载通过后，接下来分配内存。若Java堆中内存是 绝对规整的，使用“指针碰撞“方式分配内存；<br>如果不是规整的，就从空闲列表 中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，<br>也有 两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内<br>存空间初始化操作，接着是做一些必要的对象设置(元信 息、哈希码…)，后执行方法。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java 堆是否规整，有两种方<br>式：<br>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的 放在另一边。分配<br>内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小 相等的距离，这样便完成分配内<br>存工作。<br>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录 那些内存是可用<br>的，这样在分配的时候可以从列表中查询到足够大的内存分配给对 象，并在分配后更新列表记录。<br>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所 采用的垃圾收集器是否带<br>有压缩整理功能决定。</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\image-20230913180545404-169459954670713.png" alt="image-20230913180545404"></p><h4 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h4><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的 位置，在并发情况下也<br>是不安全的，可能出现正在给对象 A 分配内存，指针还 没来得及修改，对象 B 又同时使用了原来的指针<br>来分配内存的情况。解决这个 问题有两种方案：<br>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的 原子性）；<br>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆 中预先分配一小块内<br>存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪<br>个线程的 TLAB 上分配。只有 TLAB 用完并 分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参<br>数来设定虚拟机是否使 用TLAB。</p><p><img src="/2023/09/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/blog\hexo-blog\source\_posts\面试\面试\image-20230913181551016-169460015335514.png" alt="image-20230913181551016"></p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决 于 JVM 虚拟机的实现。<br>目前主流的访问方式有 句柄 和 直接指针 两种方式。<br>指针： 指向对象，代表一个对象在内存中的起始地址。<br>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是 指向对象的指针<br>（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的 真实内存地址。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="nacos和eureka有什么区别？"><a href="#nacos和eureka有什么区别？" class="headerlink" title="nacos和eureka有什么区别？"></a>nacos和eureka有什么区别？</h3><p>Eureka是Netflix开源的服务注册与发现组件，采用C/S架构，包含Eureka Server和Eureka Client两部分。</p><ul><li>Eureka Server负责服务注册与发现。</li><li>Eureka Client负责服务的提供者和消费者。</li></ul><p>Nacos是阿里巴巴开源的动态服务发现、配置管理和服务管理平台，用于构建云原生应用。Nacos支持多个注册中心实现，包括Eureka、Consul等。</p><p><strong>1. 数据持久性：</strong></p><ul><li>Nacos（前身为阿里巴巴的 Nacos）是一个功能更全面的服务注册和配置中心，支持服务注册、服务发现、配置管理和命名空间等功能。Nacos具有持久性存储，这意味着它可以将服务注册信息和配置数据持久保存在数据库中，以便在重启后保留数据。这使得Nacos更适合于生产环境，因为它能够保持服务注册信息的可靠性。</li><li>Eureka 是Netflix开发的服务发现工具，它主要关注服务注册和发现。Eureka的设计理念是最初的注册信息是暂时性的，Eureka 假定注册的服务会定期发送心跳来保持其活动状态。Eureka 不具备持久性存储，因此在某些情况下可能会丢失服务注册信息，不太适合在生产环境中作为唯一的服务注册中心使用。</li></ul><p><strong>2.支持的编程语言：</strong></p><ul><li>Nacos 提供了更广泛的编程语言支持，可以与多种编程语言和技术栈一起使用。</li><li>Eureka 主要与Java和Spring框架集成得更紧密，虽然也可以与其他编程语言一起使用，但对于非Java生态系统来说，可能需要更多的自定义工作。</li></ul><p><strong>3. 社区活跃性：</strong></p><ul><li>Nacos：Nacos有一个活跃的社区，得到了阿里巴巴的支持，并持续推出新的功能和改进。这意味着Nacos在未来会继续得到维护和升级，使其更加健壮和安全。</li><li>Eureka：Eureka的维护状态相对较低，Netflix已经停止了对Eureka的主要维护。虽然它仍然可以在一些项目中使用，但不太可能得到新功能的更新和改进。</li></ul><p><strong>4. 功能：</strong></p><ul><li>Nacos：Nacos不仅支持服务注册和发现，还提供了配置管理、命名空间、健康检查等额外的功能。您可以使用Nacos来集中管理应用程序的配置，从而简化配置管理。</li><li>Eureka：Eureka主要关注服务注册和发现，不包括配置管理等附加功能。它专注于服务注册和监控。</li></ul><p><strong>5.健康检查机制：</strong></p><ul><li>Eureka使用心跳和续约机制来检测服务的健康状态。服务提供者会定期向Eureka服务器发送心跳信号，如果Eureka服务器在配置的时间内没有收到心跳，则会将服务标记为下线。</li><li>Nacos使用心跳和异步通知机制来检测服务的健康状态。</li></ul><p><strong>6.动态配置支持</strong>：</p><ul><li>Nacos作为全能的配置中心，可以提供动态配置的支持。我们可以在Nacos中配置不同环境的配置、配置版本管理和历史记录等。</li><li>Eureka并不具备支持动态配置的能力，通常需要与其他配置中心集成，如Spring Cloud Config。</li></ul><p>总之，Nacos在功能、可靠性和多语言支持方面都提供了更全面的解决方案，适用于更广泛的应用场景。Eureka可能适用于特定情况，尤其是在Java和Spring生态系统中使用的项目，但由于维护状态的问题，通常建议在新项目中选择Nacos或其他现代化的替代方案。</p><h3 id="微服务心跳检测"><a href="#微服务心跳检测" class="headerlink" title="微服务心跳检测"></a>微服务心跳检测</h3><p>微服务心跳检测是一种用于确保微服务应用程序的可用性和健康状态的重要机制。通过定期发送心跳信号并监控这些信号，您可以检测微服务是否正常运行，并在发生故障或不可用性时采取适当的措施。以下是微服务心跳检测的关键概念和实施步骤：</p><p><strong>1. 什么是微服务心跳检测：</strong></p><ul><li>微服务心跳检测是一种监控机制，其中每个微服务实例定期（通常是几秒或几分钟一次）发送一个心跳信号到某个中心化的服务注册表或健康检查服务。这个心跳信号通常包含了微服务的元数据和状态信息。</li></ul><p><strong>2. 实施步骤：</strong></p><ul><li><strong>服务注册：</strong> 首先，每个微服务实例应该在启动时向服务注册中心注册自己。服务注册中心是一个集中管理微服务实例的地方，它维护了微服务实例的元数据和状态信息。</li><li><strong>心跳检测：</strong> 微服务实例定期发送心跳信号到服务注册中心。这些心跳信号通常包括微服务的健康状态、可用性和其他相关信息。如果微服务实例停止发送心跳信号，服务注册中心将视其为不可用。</li><li><strong>健康检查：</strong> 服务注册中心可以执行健康检查，以确保微服务实例的正常运行。这可以通过向微服务实例发起HTTP请求或其他适当的方式来实现。如果健康检查失败，服务注册中心将标记该实例为不健康，并通知其他组件。</li><li><strong>故障处理：</strong> 当某个微服务实例被标记为不健康或不可用时，根据您的需求，可以采取不同的故障处理措施，例如启动新的实例、自动扩展、发送警报或者负载均衡到其他健康的实例。</li></ul><p><strong>3. 使用工具和框架：</strong></p><ul><li>许多微服务框架和平台都提供了内置的心跳检测和健康检查机制。例如，Spring Cloud、Netflix Eureka、Kubernetes等都具有这些功能。</li><li>另外，您也可以使用监控工具如Prometheus、Grafana等，以可视化方式监控微服务的健康状态和心跳信息。</li></ul><p><strong>4. 高可用性和容错性：</strong></p><ul><li>通过使用心跳检测，您可以实现微服务应用程序的高可用性。如果某个微服务实例不可用，请求可以路由到其他健康的实例。</li><li>考虑使用负载均衡器来自动将请求分发到可用的微服务实例，以提高容错性和性能。</li></ul><p><strong>5. 集成监控和警报：</strong></p><ul><li>将微服务心跳检测集成到监控和警报系统中，以便能够及时发现和响应故障。</li><li>设置阈值和警报规则，以便在微服务不可用或不健康时及时通知运维团队。</li></ul><p>微服务心跳检测是确保微服务应用程序的稳定性和可用性的关键部分。它帮助您在发生故障或问题时及时采取行动，以最小化对用户的影响，并确保服务的连续性。</p><h2 id="redis如何处理缓存穿透"><a href="#redis如何处理缓存穿透" class="headerlink" title="redis如何处理缓存穿透"></a>redis如何处理缓存穿透</h2><p>Redis 可以采用多种方法来处理缓存穿透问题，缓解因频繁的无效查询请求导致的数据库压力增加。缓存穿透是指当查询一个缓存中不存在但数据库中存在的数据时，由于缓存未命中，每次请求都会导致数据库查询，从而导致数据库负载过高。</p><p>以下是处理缓存穿透的一些方法：</p><ol><li><p><strong>布隆过滤器（Bloom Filter）：</strong></p><ul><li>布隆过滤器是一种数据结构，用于快速检查一个元素是否属于一个集合，它具有低内存占用和高效的性能。</li><li>在查询缓存之前，可以使用布隆过滤器来过滤掉不可能存在于缓存中的查询请求。如果布隆过滤器判断请求数据不存在，可以避免查询缓存和数据库，从而减轻了数据库负担。</li></ul></li><li><p><strong>缓存空对象（Cache Null Values）：</strong></p><ul><li>当查询数据库后发现某个键对应的值为空（例如，数据库中没有匹配的数据），可以将这个空值缓存到Redis，但设置一个较短的过期时间，以防止将来请求时继续查询数据库。</li><li>这种方法可以避免频繁查询数据库，但仍然可以在一段时间后让缓存过期以允许数据库中的数据更新。</li></ul></li><li><p><strong>设置固定的占位值（Filling Cache）：</strong></p><ul><li>当查询数据库后发现某个键对应的值为空，可以将一个特殊的占位值（例如，”-1”或”null”）存储到缓存中，并为其设置较短的过期时间。</li><li>这可以防止对同一无效查询不断向数据库发出请求，同时减轻数据库负载。</li></ul></li><li><p><strong>限制请求频率（Request Rate Limiting）：</strong></p><ul><li>通过限制来自同一IP地址或相同查询的请求频率，可以减轻缓存穿透问题。使用诸如令牌桶令牌或漏桶算法等速率限制策略，拒绝频率过高的请求。</li></ul></li><li><p><strong>热点数据预热（Cache Warming）：</strong></p><ul><li>在系统启动时或定期预热缓存，将常用的数据加载到缓存中。这可以减少在查询时发生的缓存未命中率，从而减轻缓存穿透的影响。</li></ul></li><li><p><strong>使用分布式锁（Distributed Lock）：</strong></p><ul><li>在查询数据库之前，可以使用分布式锁来确保只有一个线程可以查询数据库，以避免多个线程同时发出相同的无效查询请求。</li></ul></li></ol><p>请注意，以上方法可以单独或组合使用，具体选择取决于您的应用程序需求和性能要求。处理缓存穿透是一个重要的缓存优化问题，需要根据具体情况采取合适的策略。</p><h2 id="redis如何和数据库做同步"><a href="#redis如何和数据库做同步" class="headerlink" title="redis如何和数据库做同步"></a>redis如何和数据库做同步</h2><p>将Redis和数据库保持同步是一个常见的需求，以确保缓存中的数据与数据库中的数据保持一致。以下是一些常见的方法来实现Redis和数据库的同步：</p><ol><li><p><strong>手动同步（Manual Synchronization）：</strong></p><ul><li>最简单的方式是手动管理数据同步。当数据库中的数据发生更改时，开发人员负责更新Redis中的对应数据。这需要开发人员确保数据一致性，并在每次数据库更改时手动更新缓存。</li></ul></li><li><p><strong>定时刷新（Scheduled Refresh）：</strong></p><ul><li>使用定时任务或调度器，定期（例如每隔一段时间）刷新Redis中的数据。这种方法适用于数据更新频率较低的情况，不需要实时同步。</li></ul></li><li><p><strong>使用数据库触发器（Database Trigger）：</strong></p><ul><li>数据库触发器可以在数据库发生更改时自动触发操作，例如将数据写入Redis。这种方法可以确保数据库和Redis之间的同步是自动的。</li></ul></li><li><p><strong>使用消息队列（Message Queue）：</strong></p><ul><li>当数据库中的数据发生更改时，可以将变更信息发布到消息队列中，然后Redis订阅消息队列并根据消息更新缓存。这种方法可以实现实时同步，并且是一种松耦合的方式。</li></ul></li><li><p><strong>使用缓存库的集成功能：</strong></p><ul><li>一些缓存库（例如Spring Cache）提供了与数据库集成的功能，可以自动处理缓存的更新。通过配置合适的缓存策略，您可以使缓存和数据库保持同步。</li></ul></li><li><p><strong>使用双写策略（Double Write Strategy）：</strong></p><ul><li>在数据库写操作完成后，再进行一次Redis写操作，确保数据在两个存储中都是一致的。这需要确保双写操作的原子性。</li></ul></li><li><p><strong>使用外部工具和框架：</strong></p><ul><li>有一些第三方工具和框架，如Redisson，可以帮助您实现Redis和数据库之间的同步。它们提供了一些内置的同步机制，可以简化同步的实现。</li></ul></li></ol><p>根据应用程序的需求和数据更新频率，您可以选择上述方法中的一个或多个来实现Redis和数据库之间的同步。需要注意的是，同步数据时需要考虑数据一致性、性能和可靠性等方面的因素，因此在设计同步策略时需要仔细考虑。</p><h3 id="定时刷新会存在时间差的问题吗"><a href="#定时刷新会存在时间差的问题吗" class="headerlink" title="定时刷新会存在时间差的问题吗"></a>定时刷新会存在时间差的问题吗</h3><p>是的，定时刷新会存在时间差的问题。在使用定时刷新策略来同步Redis和数据库时，由于刷新的时间间隔是固定的，因此可能会导致以下问题：</p><ol><li><p><strong>数据不一致性：</strong> 如果定时刷新的时间间隔相对较长，那么在数据库中的数据发生更改后，直到下一次刷新时，Redis中的数据仍然保持不变，这可能导致数据不一致的情况。</p></li><li><p><strong>性能问题：</strong> 如果定时刷新的时间间隔过于频繁，可能会导致不必要的Redis写操作，占用系统资源并降低性能。</p></li><li><p><strong>时间差问题：</strong> 即使定时刷新的时间间隔是固定的，仍然存在时间差问题。例如，如果定时刷新的间隔是每5分钟一次，那么数据更新后的4分59秒内，Redis中的数据仍然是旧的，用户可能会看到旧数据。</p></li></ol><p>为了解决时间差问题，可以考虑以下方法：</p><ul><li>缩短定时刷新的时间间隔，使其更加接近实时同步。这可以减少时间差，但可能会增加Redis的负载。</li><li>在数据库更新后，立即触发Redis的更新操作，以确保数据的实时同步。这可以通过数据库触发器、消息队列或应用程序逻辑来实现。</li><li>结合定时刷新和实时同步策略，使用定时刷新作为一种容错机制，而实时同步作为主要的同步方式，以确保数据的一致性。</li></ul><p>选择哪种策略取决于应用程序的需求和性能要求。对于需要高一致性和实时性的应用程序，倾向于使用实时同步策略。而对于较低一致性要求的应用程序，可以使用定时刷新作为一种补充方式。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="对一张千万级别的MySQL表加索引很慢，有没有快一点的方式"><a href="#对一张千万级别的MySQL表加索引很慢，有没有快一点的方式" class="headerlink" title="对一张千万级别的MySQL表加索引很慢，有没有快一点的方式"></a>对一张千万级别的MySQL表加索引很慢，有没有快一点的方式</h3><p>在处理千万级别的MySQL表并为其添加索引时，确实可能会遇到性能问题，特别是如果表的结构复杂或表中数据分布不均匀。以下是一些可能加速添加索引的方法：</p><ol><li><p><strong>使用在线索引建立工具：</strong> MySQL提供了一些在线索引建立工具，如pt-online-schema-change工具，可以在不锁定表的情况下添加索引。这允许在表仍然对读取和写入可用的情况下建立索引。</p></li><li><p><strong>分批次添加索引：</strong> 将表数据分成多个较小的批次，然后逐批次添加索引。这可以减小每次添加索引的数据量，降低了操作的复杂度。完成所有批次后，表将拥有完整的索引。</p></li><li><p><strong>禁用或减少日志：</strong> 在添加索引时，可以暂时禁用二进制日志（binary log）和慢查询日志（slow query log），以减少额外的写入操作。请确保在操作完成后重新启用日志记录。</p></li><li><p><strong>使用InnoDB存储引擎：</strong> 如果您的表使用了MyISAM存储引擎，考虑切换到InnoDB。InnoDB在添加索引时具有更好的并发性能。</p></li><li><p><strong>考虑在线DDL操作：</strong> MySQL 8.0引入了更多支持在线DDL操作的功能，如在线添加索引。如果您使用的是较早版本的MySQL，请考虑升级到MySQL 8.0或更高版本以获得更好的在线DDL支持。</p></li><li><p><strong>使用并行操作：</strong> 某些工具和脚本支持并行添加索引。这可以利用多个CPU核心来加速索引构建过程。</p></li><li><p><strong>使用覆盖索引：</strong> 如果只需查询表的一部分列，可以考虑创建覆盖索引，这样查询可以更快地执行，而不必浏览整个表。</p></li><li><p><strong>硬件升级：</strong> 如果您的MySQL服务器硬件资源有限，可以考虑升级服务器以提高计算和存储性能，从而更快地处理大型表。</p></li><li><p><strong>考虑垂直切分：</strong> 如果表非常大且不断增长，考虑将其垂直切分为多个较小的表，以减小每个表的大小，然后分别添加索引。</p></li></ol><p>无论采取哪种方法，添加索引都需要小心谨慎，特别是在生产环境中。在进行任何操作之前，请确保备份数据，并在测试环境中先进行测试以验证性能和可行性。此外，根据数据库引擎和MySQL版本的不同，操作可能会有所不同，因此请查看相应的文档和工具以获取详细信息。</p><h3 id="MySQL索引何时会发生失效"><a href="#MySQL索引何时会发生失效" class="headerlink" title="MySQL索引何时会发生失效"></a>MySQL索引何时会发生失效</h3><p>MySQL索引在某些情况下可能会失效，导致查询性能下降或无法利用索引进行优化。以下是一些导致MySQL索引失效的常见情况：</p><ol><li><p><strong>使用函数或表达式进行过滤：</strong> 当查询中的WHERE条件包含函数、表达式或计算时，索引通常无法被有效使用。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(name) <span class="operator">=</span> <span class="string">&#x27;APPLE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述查询中的<code>UPPER(name)</code>函数会导致索引失效，因为它会对<code>name</code>列的每一行进行计算。</p></li><li><p><strong>对索引列进行函数操作：</strong> 如果在查询中对索引列进行函数操作，索引也会失效。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(sale_date) <span class="operator">=</span> <span class="number">2023</span>;</span><br></pre></td></tr></table></figure><p>这里对<code>sale_date</code>列进行了<code>YEAR()</code>函数操作，导致无法使用索引。</p></li><li><p><strong>使用不等于（!=或&lt;&gt;)条件：</strong> 当查询中包含不等于条件时，索引通常无法被有效使用。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">!=</span> <span class="string">&#x27;completed&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这种情况下，通常无法使用<code>status</code>列上的索引。</p></li><li><p><strong>使用<code>OR</code>条件：</strong> 当查询中使用多个<code>OR</code>条件时，如果这些条件不涉及同一个索引列，MySQL可能无法使用索引进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;electronics&#x27;</span> <span class="keyword">OR</span> price <span class="operator">&lt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>此查询中涉及两个不同的条件，通常无法有效使用索引。</p></li><li><p><strong>对索引列进行隐式类型转换：</strong> 如果查询中对索引列进行了隐式类型转换，索引可能会失效。例如，如果索引列是整数类型，但查询中传递的是字符串，索引可能无法使用。</p></li><li><p><strong>表使用了不支持的存储引擎：</strong> 不同的存储引擎对索引的支持程度不同。某些存储引擎可能无法使用特定类型的索引或优化。</p></li><li><p><strong>数据分布不均匀：</strong> 如果数据在表中分布非常不均匀，而查询中使用的条件只涵盖了少数数据行，MySQL可能会选择不使用索引，而是执行全表扫描。</p></li><li><p><strong>表太小：</strong> 对于非常小的表，MySQL可能会选择执行全表扫描而不是使用索引，因为索引的开销可能会超过全表扫描的开销。</p></li></ol><p>要解决索引失效问题，可以考虑以下方法：</p><ul><li>优化查询，尽量避免对索引列进行函数操作或使用不等于条件。</li><li>确保查询中的条件与索引列的数据类型匹配。</li><li>使用合适的存储引擎，某些存储引擎对索引的支持更好。</li><li>创建适当的复合索引，以满足多个查询条件的需求。</li><li>使用数据库查询性能分析工具（如<code>EXPLAIN</code>语句）来检查查询计划，以确定是否使用了索引。</li><li>对于数据分布不均匀的情况，可以考虑重新分布数据或使用分区表等技术。</li></ul><p>综上所述，索引失效通常是由于查询的复杂性或不符合索引使用规则所导致的。通过合理的查询优化和索引设计，可以减少索引失效的可能性并提高查询性能。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/09/01/%E5%AE%B9%E5%99%A8/Docker/"/>
      <url>/2023/09/01/%E5%AE%B9%E5%99%A8/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="Docker基础常用命令"><a href="#Docker基础常用命令" class="headerlink" title="Docker基础常用命令"></a>Docker基础常用命令</h3><ul><li><h5 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h5></li></ul><blockquote><p>start docker</p></blockquote><ul><li><h5 id="停止Docker"><a href="#停止Docker" class="headerlink" title="停止Docker"></a>停止Docker</h5></li></ul><blockquote><p>stop docker</p></blockquote><ul><li><h5 id="重启Docker"><a href="#重启Docker" class="headerlink" title="重启Docker"></a>重启Docker</h5></li></ul><blockquote><p>restart docker</p></blockquote><ul><li><h5 id="开机自动启动"><a href="#开机自动启动" class="headerlink" title="开机自动启动"></a>开机自动启动</h5></li></ul><blockquote><p>enable docker</p></blockquote><ul><li><h5 id="查看Docker状态"><a href="#查看Docker状态" class="headerlink" title="查看Docker状态"></a>查看Docker状态</h5></li></ul><blockquote><p>status docker</p></blockquote><ul><li><h5 id="查看Docker版本号"><a href="#查看Docker版本号" class="headerlink" title="查看Docker版本号"></a>查看Docker版本号</h5></li></ul><blockquote><p>docker -v</p><p>docker -version</p><p>docker info</p></blockquote><h3 id="Docker镜像常用命令"><a href="#Docker镜像常用命令" class="headerlink" title="Docker镜像常用命令"></a>Docker镜像常用命令</h3><ul><li><h5 id="查看镜像目录"><a href="#查看镜像目录" class="headerlink" title="查看镜像目录"></a>查看镜像目录</h5></li></ul><blockquote><p>docker images</p></blockquote><ul><li><h5 id="拉取镜像，不加tag就是默认版本，加上tag就是指定版本号"><a href="#拉取镜像，不加tag就是默认版本，加上tag就是指定版本号" class="headerlink" title="拉取镜像，不加tag就是默认版本，加上tag就是指定版本号"></a>拉取镜像，不加tag就是默认版本，加上tag就是指定版本号</h5></li></ul><blockquote><p>docker pull <strong>镜像名</strong>:tag</p></blockquote><ul><li><h5 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h5></li></ul><blockquote><p>docker search 镜像名</p></blockquote><ul><li><h5 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h5></li></ul><blockquote><p>docker run <strong>镜像名</strong> </p></blockquote><ul><li><h5 id="删除镜像，加-f就是删除多个，用rm就是强制删除"><a href="#删除镜像，加-f就是删除多个，用rm就是强制删除" class="headerlink" title="删除镜像，加-f就是删除多个，用rm就是强制删除"></a>删除镜像，加-f就是删除多个，用rm就是强制删除</h5></li></ul><blockquote><p>docker rmi <strong>镜像id/镜像名称</strong> ——删除一个</p><p>docker rmi -f <strong>镜像id/镜像名称</strong> ——强制删除</p><p>docker rmi -f <strong>镜像名/镜像id 镜像名/镜像id</strong> ——删除多个镜像</p><p>docker rmi -f <strong>${docker images -aq}</strong> —— 删除全部镜像</p></blockquote><ul><li><h5 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h5></li></ul><blockquote><p>docker save <strong>镜像名称/镜像id</strong> -o 镜像保存在那个位置和取重新的名称</p><p>如：docker save MySQL -o /root/test</p></blockquote><ul><li><h5 id="加载镜像"><a href="#加载镜像" class="headerlink" title="加载镜像"></a>加载镜像</h5></li></ul><blockquote><p>任何装docker的地方加载镜像保存文件，使其恢复为一个镜像</p><p>docker load -i <strong>镜像保存文件位置</strong></p></blockquote><ul><li><h5 id="清除所有没有使用的镜像"><a href="#清除所有没有使用的镜像" class="headerlink" title="清除所有没有使用的镜像"></a>清除所有没有使用的镜像</h5></li></ul><blockquote><p>docker system prune -a</p></blockquote><h3 id="Docker容器常用命令"><a href="#Docker容器常用命令" class="headerlink" title="Docker容器常用命令"></a>Docker容器常用命令</h3><ul><li><h5 id="查看正在运行的容器列表"><a href="#查看正在运行的容器列表" class="headerlink" title="查看正在运行的容器列表"></a>查看正在运行的容器列表</h5></li></ul><blockquote><p>docker ps</p></blockquote><ul><li><h5 id="查看所有容器，包含正在运行和没有运行的容器"><a href="#查看所有容器，包含正在运行和没有运行的容器" class="headerlink" title="查看所有容器，包含正在运行和没有运行的容器"></a>查看所有容器，包含正在运行和没有运行的容器</h5></li></ul><blockquote><p>docker -a</p></blockquote><ul><li><h5 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h5></li></ul><blockquote><p>docker stop 容器名称/容器id</p></blockquote><ul><li><h5 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h5></li></ul><blockquote><p>docker restart <strong>容器名称/容器id</strong></p></blockquote><ul><li><h5 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h5></li></ul><blockquote><p>docker start <strong>容器名称/容器id</strong></p></blockquote><ul><li><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5></li></ul><blockquote><p>docker rm -f 容器名称/容器id ——删除单个容器</p><p>docker rm -f <strong>容器名称/容器id 容器名称/容器id</strong> ——删除多个容器</p><p>docker rm -f <strong>${docker ps -aq}</strong> ——删除全部容器</p></blockquote><ul><li><h5 id="运行容器详解"><a href="#运行容器详解" class="headerlink" title="运行容器详解"></a>运行容器详解</h5></li></ul><blockquote><p>docker run ——运行容器</p><p>-p ——宿主机端口：容器端口</p><p>如：<strong>-p 3307 : 3306</strong> 是把3306容器端口映射到宿主机3307端口</p><p>运行MySQL容器实例：</p><p>docker run -itd —name mysql-8 -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0</p></blockquote><ul><li><h5 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h5></li></ul><blockquote><p>docker exec -it <strong>容器名称/容器id</strong> bin/bash</p><p>或</p><p>docker exec -it <strong>容器名称/容器id</strong> /bin/bash</p></blockquote><ul><li><h5 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5></li></ul><blockquote><p>exit</p></blockquote><ul><li><h5 id="杀掉容器"><a href="#杀掉容器" class="headerlink" title="杀掉容器"></a>杀掉容器</h5></li></ul><blockquote><p>docker kill <strong>容器id/容器名称</strong></p></blockquote><ul><li><h5 id="更换容器名称"><a href="#更换容器名称" class="headerlink" title="更换容器名称"></a>更换容器名称</h5></li></ul><blockquote><p>docker rename <strong>容器id/容器名称</strong> 新容器名</p></blockquote><ul><li><h5 id="查看容器日志命令"><a href="#查看容器日志命令" class="headerlink" title="查看容器日志命令"></a>查看容器日志命令</h5></li></ul><blockquote><p>docker logs -f —tail=查询多少行 默认查询所有容器/容器名称</p></blockquote><h3 id="Docker其他常用命令"><a href="#Docker其他常用命令" class="headerlink" title="Docker其他常用命令"></a>Docker其他常用命令</h3><ul><li><h5 id="暂停容器所有进程"><a href="#暂停容器所有进程" class="headerlink" title="暂停容器所有进程"></a><strong>暂停容器所有进程</strong></h5></li></ul><blockquote><p>docker pause <strong>容器名称/容器id</strong></p></blockquote><ul><li><strong>恢复容器中所有的进程</strong></li></ul><blockquote><p>docker unpause <strong>容器名称 / 容器ID</strong></p></blockquote><ul><li><strong>创建一个新的容器但不启动它</strong></li></ul><blockquote><p>docker create [OPTIONS] IMAGE [COMMAND] [ARG…]<br>例如:nginx<br>docker create —name myrunoob nginx:latest</p></blockquote><ul><li><strong>查看docker工作目录</strong></li></ul><blockquote><p>sudo docker info |grep “docker root dir”</p></blockquote><ul><li><strong>查看docker磁盘暂用情况</strong></li></ul><blockquote><p>du -hs /var/lib/docker</p></blockquote><ul><li><strong>文件拷贝进容器</strong></li></ul><blockquote><p>docker cp <strong>容器id:/文件目录/文件名 /主机文件目录</strong></p></blockquote><ul><li><strong>查看镜像的元数据</strong></li></ul><blockquote><p>docker inspect <strong>容器id</strong></p></blockquote><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><img src="/2023/09/01/%E5%AE%B9%E5%99%A8/Docker/image-20240514042835080-17156321167378.png" alt="image-20240514042835080"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>查看端口是否被占用，之后重启网络连接</p><p>通过管理员执行CMD或powerShell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 端口是否被占用</span><br><span class="line">netstat -ano | findstr :3306</span><br></pre></td></tr></table></figure><p>返回空白则为未被占用</p><p>重启winnat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net stop winnat</span><br><span class="line">#docker start container_name</span><br><span class="line">net start winnat</span><br></pre></td></tr></table></figure><h2 id="Windows环境通过docker安装Redis"><a href="#Windows环境通过docker安装Redis" class="headerlink" title="Windows环境通过docker安装Redis"></a>Windows环境通过docker安装Redis</h2><h3 id="拉取Redis"><a href="#拉取Redis" class="headerlink" title="拉取Redis"></a>拉取Redis</h3><p>以管理员身份运行CMD或powerShell，执行如下命令拉取Redis</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p><img src="/2023/09/01/%E5%AE%B9%E5%99%A8/Docker/image-20240513214018760-17156076221921.png" alt="image-20240513214018760"></p><h3 id="在本地硬盘中创建Redis目录"><a href="#在本地硬盘中创建Redis目录" class="headerlink" title="在本地硬盘中创建Redis目录"></a>在本地硬盘中创建Redis目录</h3><p>在E盘中新建Redis目录，在目录下新建Conf和Data目录，分别用于挂在配置文件和存放数据持久化文件。</p><p>创建<strong>redis.conf</strong>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#密码,本地环境可不配，配置的密码务必复杂，Redis性能很高(150w/s)，弱密码很快就可以撞库破解</span><br><span class="line">#requirepass 123</span><br><span class="line">#最大连接数</span><br><span class="line">maxclients 10000</span><br><span class="line"></span><br><span class="line">#如果要外网访问，请注释掉下面，或者修改为0.0.0.0，保险起见，也可以把protected-mode设置为no</span><br><span class="line">#bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line">#注意修改这里端口，根据你实际暴露端口情况配置</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">#注意!! 这里要把后台运行设置为no，避免docker后台运行冲突</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line">supervised no</span><br><span class="line">pidfile /docker/redis/redis.pid</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">always-show-logo yes</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#注意修改这里的目录为容器内目录，默认reids进来是在/data/目录</span><br><span class="line">dir /data/</span><br><span class="line"></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line">replica-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">replica-priority 100</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line">#注意修改这里的配置，yes开启持久化，no关闭持久化</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">dynamic-hz yes</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将文件存放在<strong>E:\softwares\Redis\Conf</strong>目录下</p><h3 id="构建并启动Redis容器"><a href="#构建并启动Redis容器" class="headerlink" title="构建并启动Redis容器"></a>构建并启动Redis容器</h3><p>执行如下命令构建并启动Redis容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --privileged=true --restart=always -p 6379:6379 -v E:/softwares/Redis/Conf/redis.conf:/etc/redis/redis.conf -v E:/softwares/Redis/Data:/data --name redis7 redis:7.0 redis-server /etc/redis/redis.conf --appendonly yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令解析：</p><blockquote><ul><li><code>docker run</code>：启动一个新的容器。</li><li><code>-d</code>：以后台模式运行容器。</li><li><code>--privileged=true</code>：给予容器特权模式，使容器可以访问主机上的设备和其他资源。</li><li><code>--restart=always</code>：在容器退出时自动重启。</li><li><code>-p 6379:6379</code>：将容器内的Redis端口6379映射到主机上的6379端口。</li><li><code>-v E:/softwares/Redis/Conf/redis.conf:/etc/redis/redis.conf</code>：将主机上<code>E:/softwares/Redis/Conf/redis.conf</code>文件的内容挂载到容器内的<code>/etc/redis/redis.conf</code>路径下。</li><li><code>-v E:/softwares/Redis/Data:/data</code>：将主机上<code>E:/softwares/Redis/Data</code>目录的内容挂载到容器内的<code>/data</code>路径下。</li><li>`—name redis67：为容器指定一个名称。</li><li><code>redis:7.0</code>：使用Redis镜像版本7.0创建容器。</li><li><code>redis-server /etc/redis/redis.conf --appendonly yes</code>：在容器内启动Redis服务器，使用挂载的配置文件，并设置追加写入模式。</li></ul></blockquote><p><img src="/2023/09/01/%E5%AE%B9%E5%99%A8/Docker/image-20240514000104027-17156160656625.png" alt="image-20240514000104027"></p><h2 id="Docker相关面试题"><a href="#Docker相关面试题" class="headerlink" title="Docker相关面试题"></a>Docker相关面试题</h2><h3 id="什么是Docker容器？"><a href="#什么是Docker容器？" class="headerlink" title="什么是Docker容器？"></a>什么是Docker容器？</h3><p>Docker是一种流行的开源软件平台，可简化创建、管理、运行和分发应用程序的过程。它使用容器来打包应用程序及其依赖项。也可将容器视为Docker镜像运行的实例。</p><h3 id="Docker和虚拟机有什么不同？"><a href="#Docker和虚拟机有什么不同？" class="headerlink" title="Docker和虚拟机有什么不同？"></a>Docker和虚拟机有什么不同？</h3><p>Docker是轻量级的沙盒，在其中运行的只是应用，而虚拟机中还有额外的系统。</p><blockquote><p>沙盒：也叫沙箱，在计算机安全领域中是一种安全机制，为运行的程序提供的隔离环境。</p></blockquote><h3 id="什么是DockerFile"><a href="#什么是DockerFile" class="headerlink" title="什么是DockerFile?"></a>什么是DockerFile?</h3><p>DockerFile是一个文本文件，其中包含我们需要运行以构建Docker镜像的所有命令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。Docker使用DockerFile中的指令自动构建镜像。我们可以使用<strong>docker build</strong> 用来创建顺序执行多个命令行指令的自动构建。</p><blockquote><ul><li><p>FROM ：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条指令。</p></li><li><p>LABEL： LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。</p></li><li><p>RUN： RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。</p></li><li><p>CMD： 使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个 CMD 指令，只有最后的 CMD 指令运行。</p></li></ul></blockquote><h3 id="使用Docker-Compose时如何保证容器A先于容器B运行？"><a href="#使用Docker-Compose时如何保证容器A先于容器B运行？" class="headerlink" title="使用Docker Compose时如何保证容器A先于容器B运行？"></a>使用Docker Compose时如何保证容器A先于容器B运行？</h3><blockquote><p>Docker Compose 是一个用来定义和运行复杂应用的Docker工具。</p><p>一个使用Docker容器的应用，通常由多个容器组成，使用Docker Compose不再需要使用shell脚本来启动容器。</p><p>Compose通过一个配置文件来管理多个Docker容器。</p><p>简单理解Docker Compose是Docker的管理工具。</p></blockquote><p>Docker Compose在继续下一个容器之前不会等待容器准备就绪。</p><p>为了控制我们的执行顺序，我们开源使用“取决于”条件，在<strong>depends_on</strong>。</p><p>以下是在docker-commpose.yml文件中使用的示例</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2.4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">backend:</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">build:</span> <span class="string">.</span>    <span class="comment"># 构建自定义镜像</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">depends_on:</span></span><br><span class="line"></span><br><span class="line">     <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">db:</span></span><br><span class="line"></span><br><span class="line">   <span class="attr">image:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p>用<strong>docker-compose up</strong>命令按照我们指定的依赖顺序启动和运行服务。</p><h3 id="一个完整的Docker由哪些部分组成"><a href="#一个完整的Docker由哪些部分组成" class="headerlink" title="一个完整的Docker由哪些部分组成"></a>一个完整的Docker由哪些部分组成</h3><ul><li>Docker Client 客户端</li><li>Docker Daemon 守护进程</li><li>Docker Image 镜像</li><li>Docker Container 容器</li></ul><h3 id="描述Docker容器的生命周期"><a href="#描述Docker容器的生命周期" class="headerlink" title="描述Docker容器的生命周期"></a>描述Docker容器的生命周期</h3><ol><li>创建容器</li><li>运行容器</li><li>暂停容器（可选）</li><li>取消暂停容器（可选）</li><li>启动容器</li><li>停止容器</li><li>重启容器</li><li>杀死容器</li><li>销毁容器</li></ol>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料分析公式</title>
      <link href="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="主要考点有七大类"><a href="#主要考点有七大类" class="headerlink" title="主要考点有七大类"></a>主要考点有七大类</h2><ul><li>直接查找</li><li>增长量/增长率</li><li>现期/基期</li><li>比重</li><li>平均数</li><li>和差倍比简单计算（加减乘除）</li><li>比较大小</li></ul><h3 id="一、现期、基期、增长量、增长率"><a href="#一、现期、基期、增长量、增长率" class="headerlink" title="一、现期、基期、增长量、增长率"></a>一、<strong>现期、基期、增长量、增长率</strong></h3><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-bf875653f1b630adb18b3aa7208265e0_720w.jpeg" alt="img"></p><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-57d8d29ad895333a0953e54e07f7d225_720w.jpeg" alt="img"></p><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-8dcb726251853c6f9d2ad755b4d0be21_720w.jpeg" alt="img"></p><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-e77e714a4d842159d8f365289e94c26f_720w.webp" alt="img"></p><p>（整体增长率介于两个部分增长率之间）</p><h3 id="二、年均增长量、年均增长率"><a href="#二、年均增长量、年均增长率" class="headerlink" title="二、年均增长量、年均增长率"></a><strong>二、年均增长量、年均增长率</strong></h3><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-1d9fd46dddd4b7b572301dbbe46eeb9c_720w.webp" alt="img"></p><h3 id="三、比重"><a href="#三、比重" class="headerlink" title="三、比重"></a><strong>三、比重</strong></h3><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-6dcd7f99ad4ace85930a1f2f64edd4a8_720w.jpeg" alt="img"></p><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-59a3ecedbe3901a4a35733deb8b522ab_720w.jpeg" alt="img"></p><p><img src="/2023/06/25/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F/v2-81085e08cfcaef8f0e186c091e3f8951_720w.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 公务员 </category>
          
          <category> 行测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料分析公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>言语理解与表达</title>
      <link href="/2023/03/13/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3%E4%B8%8E%E8%A1%A8%E8%BE%BE/"/>
      <url>/2023/03/13/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3%E4%B8%8E%E8%A1%A8%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="言语理解与表达"><a href="#言语理解与表达" class="headerlink" title="言语理解与表达"></a>言语理解与表达</h1>]]></content>
      
      
      <categories>
          
          <category> 公务员 </category>
          
          <category> 行测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 言语理解与表达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料分析</title>
      <link href="/2023/03/12/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/12/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="资料分析"><a href="#资料分析" class="headerlink" title="资料分析"></a>资料分析</h1><h2 id="除法计算"><a href="#除法计算" class="headerlink" title="除法计算"></a>除法计算</h2><blockquote><p>重点看选项！</p></blockquote><ul><li>分子不变，分母四舍五入截位</li><li>选项首位都不同，分母截2位；选项首位有相同，分母截3位</li><li>选项的数量级相同，则不考虑小数点位置（如末尾的0，中间的.）</li><li>结合选项的大数确定商是多少</li></ul><p><img src="/2023/03/12/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/image-20230312134951085.png" alt="image-20230312134951085"></p><h3 id="乘法计算"><a href="#乘法计算" class="headerlink" title="乘法计算"></a>乘法计算</h3><ul><li>直接划分数</li><li>拆分（尽量拆成有倍数关系的）</li></ul><p>两个分数化一个</p><p><img src="/2023/03/12/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/image-20230312144154334.png" alt="image-20230312144154334"></p><script type="math/tex; mode=display">\frac{1}{2} = 50</script><script type="math/tex; mode=display">\frac{1}{3} = 33.3%</script><script type="math/tex; mode=display">\frac{1}{4} = 25%</script><script type="math/tex; mode=display">\frac{1}{5} = 20%</script><script type="math/tex; mode=display">\frac{1}{6} = 16.7%</script><script type="math/tex; mode=display">\frac{1}{7} = 14.3%</script><script type="math/tex; mode=display">\frac{1}{8} = 12.5%</script><script type="math/tex; mode=display">\frac{1}{9} = 11.1%</script><script type="math/tex; mode=display">\frac{1}{10} = 10%</script><script type="math/tex; mode=display">\frac{1}{11} = 9.1%</script><script type="math/tex; mode=display">\frac{1}{12} = 8.3%</script><script type="math/tex; mode=display">\frac{1}{13} = 7.7%</script><script type="math/tex; mode=display">\frac{1}{14} = 7.2%</script><script type="math/tex; mode=display">\frac{1}{15} = 6.6%</script><script type="math/tex; mode=display">\frac{1}{16} = 6.3%</script><h3 id="化乘为除"><a href="#化乘为除" class="headerlink" title="化乘为除"></a>化乘为除</h3><p><strong>r的绝对值 &lt;= 5%</strong></p><p><img src="/2023/03/12/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/image-20230312174255288.png" alt="image-20230312174255288"></p><h3 id="加减计算"><a href="#加减计算" class="headerlink" title="加减计算"></a>加减计算</h3><ul><li>精度相同且尾数不同   (<strong>位数法</strong>)</li><li>偶数位留一半，奇数位留前一多半（<strong>截位法 别忘记四舍五入</strong>）</li></ul><h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><ul><li>除法</li><li>加法</li><li>乘法</li></ul><p>先排除 （<strong>商的量级</strong>——只看分子与分母的整数部分）  </p><p>再计算</p><h3 id="增长量计算"><a href="#增长量计算" class="headerlink" title="增长量计算"></a>增长量计算</h3><p>求某个量增长或减少且是具体单位</p><p>现期量 - 基期量</p><h3 id="增长量比大小"><a href="#增长量比大小" class="headerlink" title="增长量比大小"></a>增长量比大小</h3><ul><li>大大为大：现期量大，增长率也大，增常量大</li><li>一大一小：看现期量×增长率，乘积越大，增长量越大</li></ul><h3 id="增长率计算"><a href="#增长率计算" class="headerlink" title="增长率计算"></a>增长率计算</h3><p>求增长/减少且单位是%</p><p>给定一个增长率，再给定一个百分点 ，求另一个增长率，<strong>百分点加减计算</strong></p><p>给定具体量，求增长率，<strong>（增长量/基期量）× 100%</strong></p>]]></content>
      
      
      <categories>
          
          <category> 公务员 </category>
          
          <category> 行测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行测题型</title>
      <link href="/2023/03/12/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B%E9%A2%98%E5%9E%8B/"/>
      <url>/2023/03/12/%E5%85%AC%E5%8A%A1%E5%91%98/%E8%A1%8C%E6%B5%8B%E9%A2%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="行测题型"><a href="#行测题型" class="headerlink" title="行测题型"></a>行测题型</h1><p>资料分析——&gt;言语理解与表达——&gt;判断推理——&gt;数量关系——&gt;常识判断</p><p>华图的模块宝典和1000题  </p><h2 id="言语理解与表达"><a href="#言语理解与表达" class="headerlink" title="言语理解与表达"></a>言语理解与表达</h2><p>多积累，多总结。</p><h2 id="判断推理"><a href="#判断推理" class="headerlink" title="判断推理"></a>判断推理</h2><p>技巧性最强。</p><h3 id="包含四个题型"><a href="#包含四个题型" class="headerlink" title="包含四个题型"></a>包含四个题型</h3><ul><li>图形推理</li><li>定义判断</li><li>类比推理</li><li>逻辑判断</li></ul><h2 id="数量关系"><a href="#数量关系" class="headerlink" title="数量关系"></a>数量关系</h2><p>最难</p><h2 id="常识判断"><a href="#常识判断" class="headerlink" title="常识判断"></a>常识判断</h2><p>政治和法律</p><h2 id="资料分析"><a href="#资料分析" class="headerlink" title="资料分析"></a>资料分析</h2><p>最有可能满分</p>]]></content>
      
      
      <categories>
          
          <category> 公务员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>JDK5及以上版本提供了对线程池的支持，主要用于支持高并发的访问处理，并且复用线程对象。</p><p>JVM先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果线程数量超过了最大线程数量（用户设置的线程池的大小），则超出数量的线程排队等候，再有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。</p><p>线程池核心原理是创建一个“线程池”(ThreadPool)，在池中对线程对象进行管理，包括创建与销毁，使用池时只需要执行具体的任务即可，线程对象的处理都在池中被封装了。</p><p>线程池类TheadPoolExecutor实现了Executor接口。</p><h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h3><p>在Java中，每个Thread类都有一个start方法。在程序调用start方法启动线程时，Java虚拟机会调用该类的run方法。在Thread类的run方法中其实调用了Runnable对象的run方法，因此可以继承Thread类，在start方法中不断循环调用传递进来的Runnable对象，程序就会不断执行run方法中的代码。可以将在循环方法中不断获取Runnable对象存放在Queue中，当前线程在获取下一个Runnbale对象之前可以是阻塞的，这样既可以有效控制正在执行的线程个数，也能保证系统中正在等待执行的其他线程有序执行。这样就简单实现了一个线程池，达到了线程多路复用的效果。</p><h3 id="核心组件和核心类"><a href="#核心组件和核心类" class="headerlink" title="核心组件和核心类"></a>核心组件和核心类</h3><ul><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中执行具体任务的线程</li><li>任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。</li><li>任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。</li></ul><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303162116152.png" alt="image-20230303162116152"></p><p>ThreadPoolExecutor是构建线程的核心方法：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303162459322.png" alt="image-20230303162459322"></p><p>具体参数含义如下：</p><div class="table-container"><table><thead><tr><th>序号</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>corePoolsize</td><td>线程池中核心线程的数量</td></tr><tr><td>2</td><td>maximumPoolSize</td><td>线程池中最大线程的数量</td></tr><tr><td>3</td><td>keepAliveTime</td><td>当前线程数量超过corePoolSize时，空闲线程的存活时间</td></tr><tr><td>4</td><td>unit</td><td>keepAliveTime时间单位</td></tr><tr><td>5</td><td>workQueue</td><td>任务队列，被提交但尚未被执行的任务存放的地方</td></tr><tr><td>6</td><td>threadFactory</td><td>线程工厂，用于创建线程，可使用默认的线程工厂或自定义线程工厂</td></tr><tr><td>7</td><td>handler</td><td>由于任务过多或其他原因导致线程池无法处理时的任务拒绝策略</td></tr></tbody></table></div><h2 id="Java线程池的工作流程"><a href="#Java线程池的工作流程" class="headerlink" title="Java线程池的工作流程"></a>Java线程池的工作流程</h2><p>Java线程池的工作流程为：线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用execute()添加一个任务时，线程池会按照以下流程执行任务。</p><ol><li>如果正在运行的线程数量少于 corePoo!Size （用户定义的核 线程数 ，线程池就会立刻 建线程并执行该线程任务。</li><li>如果正在运行的线程数量大于等于 corePoolSize ，该任务就将被放入阻 队列中。</li><li>在阻 队列己满且正在运行的线程数量少于 maximumPoolSize 时，线程池会创建非核心线程立刻执行该线程任务。</li><li>在阻塞队列已满且正在运行的线程数量大于等于 maximumPoo!S ze 时，线程池将拒绝执行该线程任务并抛出 RejectExecutionException 异常。</li><li>在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。</li><li>在线程处于空闲状态的时 超过 keepAliveTime 时间时，正在运行的线程数量超过corePoolSize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corePoolSize大小。</li></ol><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307153442063.png" alt="image-20230307153442063"></p><h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303100123837.png" alt="image-20230303100123837"></p><p>仅有一个execute()方法。</p><h3 id="使用Executors工厂类创建线程池"><a href="#使用Executors工厂类创建线程池" class="headerlink" title="使用Executors工厂类创建线程池"></a>使用Executors工厂类创建线程池</h3><p>Executor接口仅仅是一种规范，一种声明，一种定义，它没有实现任何功能。</p><p>所以需要使用接口的实现类来完成指定的功能，如ThreadPoolExecutor就是Executor的实现类。</p><p>但ThreadPoolExecutor在实例化时需要传入多个参数，还要考虑线程的并发数等与线程池运行效率有关的参数，所以建议使用Executors工厂类来创建线程池对象。该类对创建ThreadPoolExecutor线程池进行封装，直接调用即可。</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303101001993.png" alt="image-20230303101001993"></p><h2 id="5种常用的线程池"><a href="#5种常用的线程池" class="headerlink" title="5种常用的线程池"></a>5种常用的线程池</h2><div class="table-container"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>可缓存的线程池</td></tr><tr><td>newFixdedThreadPool</td><td>固定大小的线程池</td></tr><tr><td>newScheduledThreadPool</td><td>可做任务调度的线程池</td></tr><tr><td>newSingleThreadExecutor</td><td>单个线程的线程池</td></tr><tr><td>newWorkStealingPool</td><td>足够大小的线程池，JDK1.8新增</td></tr></tbody></table></div><h3 id="使用newCachedThreadPool-方法创建无界线程池"><a href="#使用newCachedThreadPool-方法创建无界线程池" class="headerlink" title="使用newCachedThreadPool()方法创建无界线程池"></a>使用newCachedThreadPool()方法创建无界线程池</h3><p>使用Executors类的newCachedThreadPool()方法创建无界线程池，可以进行线程自动回收。所谓“无界线程池”就是池中存放线程个数是理论上的最大值，即Integer.MAX_VALUE。</p><p>在创建新线程时，如果有可重用的线程，则重用它们，否则创建一个新的线程并添加到线程池中。对于执行时间很短的任务而言，newCachedThreadPool线程池能很大程度地重用线程而提高系统的性能。</p><p>在线程池的keepAliveTime时间超过默认的60秒后，该线程会被终止并从缓存中移除，因此在没有线程运行时，newCachedThreadPool将不会占用系统的线程资源。</p><p>在有执行时间很短的大量任务需要执行的情况下， newCachedThreadPool能够很好地复用运行中的线程（任务已经完成但未关闭的线程）资源来提高系统的运行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedTheadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool()</span><br></pre></td></tr></table></figure><p>创建类Run：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303101455735.png" alt="image-20230303101455735"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303101511065.png" alt="image-20230303101511065"></p><p>A和B机会是在相同的时间开始打印的，也就是创建了2个线程，而且2个线程之间是异步运行的。</p><p>创建Run类：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303101644182.png" alt="image-20230303101644182"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303101701162.png" alt="image-20230303101701162"></p><p>循环打印也可成功。</p><h3 id="验证newCachedThreadPool-方法创建线程池和线程复用特性"><a href="#验证newCachedThreadPool-方法创建线程池和线程复用特性" class="headerlink" title="验证newCachedThreadPool()方法创建线程池和线程复用特性"></a>验证newCachedThreadPool()方法创建线程池和线程复用特性</h3><p>创建类MyRunnable：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303102518668.png" alt="image-20230303102518668"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建运行类Run：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303102628316.png" alt="image-20230303102628316"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303102701009.png" alt="image-20230303102701009"></p><p>线程中对象复用</p><p>创建类MyRunnable：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303103135535.png" alt="image-20230303103135535"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建运行类：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303103155301.png" alt="image-20230303103155301"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303103222977.png" alt="image-20230303103222977"></p><p>线程池中线程对象只有处于闲置状态时才可以被复用。</p><h3 id="使用newCachedThreadPool-ThreadFactory-方法定制线程工厂"><a href="#使用newCachedThreadPool-ThreadFactory-方法定制线程工厂" class="headerlink" title="使用newCachedThreadPool(ThreadFactory)方法定制线程工厂"></a>使用newCachedThreadPool(ThreadFactory)方法定制线程工厂</h3><p>无界线程池中创建线程类的过程是可以定制的，可以使用类newCachedThreadPool()方法。</p><p>创建线程类MyThreadFactory：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303134342824.png" alt="image-20230303134342824"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建运行类Run：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303134649309.png" alt="image-20230303134649309"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303134749726.png" alt="image-20230303134749726"></p><p>通过使用自定义的ThreadFactory接口实现类，实现了线程对象的定制性。</p><p>ThreadPoolExecutor、ThreadFactory和Thread之间的关系是ThreadPoolExecutor类使用ThreadFactory方法创建Thread对象。</p><p>内部源码：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303135139260.png" alt="image-20230303135139260"></p><p>在源代码中使用了默认工厂，源代码如下：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303135236932.png" alt="image-20230303135236932"></p><p>Executors.defaultThreadFactory()方法源代码如下：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303135333685.png" alt="image-20230303135333685"></p><p>DefaultThreadFactory类实现关系：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303135425732.png" alt="image-20230303135425732"></p><p>使用无参数的public static ExecutorService newCached-ThreadPool()方法创建线程池时，在内部隐式地使用了DefaultThreadFactory类。</p><blockquote><p>在高并发的情况下，使用newCachedThreadPool()方法创建无界线程池极易造成内存占用率大幅升高，导致内存溢出或者系统运行效率严重下降。</p></blockquote><h3 id="使用newFixdThreadPool-int-方法创建有界线程池"><a href="#使用newFixdThreadPool-int-方法创建有界线程池" class="headerlink" title="使用newFixdThreadPool(int)方法创建有界线程池"></a>使用newFixdThreadPool(int)方法创建有界线程池</h3><p>newFixdThreadPool(int)方法用于创建一个固定线程数量的线程池，并将线程资源存放在队列中循环使用。在newFixedThreadPool线程池中，若处于活动状态的线程数量大于等于核心线程池的数量，则新提交的任务将在阻塞队列中排队，直到有可用的线程资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>创建类MyRunnable：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303140556138.png" alt="image-20230303140556138"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建运行类Run：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303141052361.png" alt="image-20230303141052361"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303141119097.png" alt="image-20230303141119097"></p><p>使用有界线程池后线程池中的最多线程个数是可控的。</p><h3 id="使用newSingleThreadExecutor-方法创建单一线程池"><a href="#使用newSingleThreadExecutor-方法创建单一线程池" class="headerlink" title="使用newSingleThreadExecutor()方法创建单一线程池"></a>使用newSingleThreadExecutor()方法创建单一线程池</h3><p>使用newSingleThreadExecutor()方法可以创建单一线程池，单一线程池可以实现以队列的方式来执行任务。</p><p>newSingleThreadExecutor线程池会保证永远有且只有一个可用的线程，在该线程停止或发生异常时，newSingleThreadExecutor线程池会启动一个新的线程来代替该线程继续执行任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThread = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p>创建MyRunnable类：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303141334119.png" alt="image-20230303141334119"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建运行类Run：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303141356758.png" alt="image-20230303141356758"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230303141439527.png" alt="image-20230303141439527"></p><p>可以看见只有一个线程在运行。</p><h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><p>newWorkStealingPool创建持有足够线程的线程池来达到快速运算的目的，在内部通过使用多队列来减少各个线程调度产生的竞争。这里所说的有足够的线程指JDK根据当前线程的运行需求向操作系统申请足够的线程，以保障线程的快速执行，并很大程度地使用系统资源，提高并发计算的效率，省去用户根据CPU资源估算并行度的过程。当</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><p>newScheduledThreadPool创建了一个可定时调度的线程池，可设置在给定的延迟时间后执行或者定期执行某个线程任务。</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307170244156.png" alt="image-20230307170244156"></p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>当线程池的核心线程数已被用完并且阻塞队列已经排满，线程池将通过拒绝策略来处理新增的线程任务。</p><p>JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这4种，默认的拒绝策略在ThreadPoolExecutor中作为内部类提供。当默认的拒绝策略不能满足应用需求时可以自定义拒绝策略。</p><h3 id="1、AbortPolicy"><a href="#1、AbortPolicy" class="headerlink" title="1、AbortPolicy"></a>1、AbortPolicy</h3><p>AbortPolicy会直接抛出异常，阻止线程运行，源码如下：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307160110870.png" alt="image-20230307160110870"></p><h3 id="2、CallerRunsPolicy"><a href="#2、CallerRunsPolicy" class="headerlink" title="2、CallerRunsPolicy"></a>2、CallerRunsPolicy</h3><p>CallerRunsPolicy的拒绝策略为：如果被丢弃的线程任务未关闭，则执行该线程任务。CallerRunsPolicy拒绝策略不会真的丢弃任务，源码如下：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307160338478.png" alt="image-20230307160338478"></p><h3 id="3、DiscardOldestPolicy"><a href="#3、DiscardOldestPolicy" class="headerlink" title="3、DiscardOldestPolicy"></a>3、DiscardOldestPolicy</h3><p>DiscardOldestPolicy的拒绝策略为：移除线程队列中最早的一个线程任务，并尝试提交当前任务，源码如下：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307160448200.png" alt="image-20230307160448200"></p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307160500298.png" alt="image-20230307160500298"></p><h3 id="4、DiscardPolicy"><a href="#4、DiscardPolicy" class="headerlink" title="4、DiscardPolicy"></a>4、DiscardPolicy</h3><p>DiscardPolicy的拒绝策略为：丢弃当前的线程任务不做任何处理，如果系统允许在资源不足的情况下丢弃部分任务，则该策略是一种可以保障系统安全稳定的方案，源码如下：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307160856035.png" alt="image-20230307160856035"></p><h3 id="5、自定义拒绝策略"><a href="#5、自定义拒绝策略" class="headerlink" title="5、自定义拒绝策略"></a>5、自定义拒绝策略</h3><p>以上策略均实现了RejectedExecutionHandler接口。用户也可以自己扩展RejectedExecutionHandler接口来实现拒绝策略，并捕获异常来实现自定义拒绝策略。</p><p>下面是一个自定义拒绝策略DiscardOldestNPolicy，该策略根据传入的参数丢弃最老的N个线程，源码如下：</p><p><img src="/2023/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161253407.png" alt="image-20230307161253407"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发集合框架</title>
      <link href="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="并发集合框架"><a href="#并发集合框架" class="headerlink" title="并发集合框架"></a>并发集合框架</h1><p>Java语言中的集合框架父接口是Iterable，从这个接口向下一一继承就 可以得到完整的Java集合框架结构。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302105346240.png" alt="image-20230302105346240"></p><p>可以看见三个继承分支（List、Set、Queue）的接口是collection，它是集合框架主要功能的抽象，另一个接口是Iterable。</p><h2 id="接口Iterable"><a href="#接口Iterable" class="headerlink" title="接口Iterable"></a>接口Iterable</h2><p>接口Iterable的主要作用是迭代循环。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302110035800.png" alt></p><p>方法iterator()：通过此方法返回Iterator对象。</p><h2 id="接口Collection"><a href="#接口Collection" class="headerlink" title="接口Collection"></a>接口Collection</h2><p>接口Collection提供了集合框架最主要、最常用的操作。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302110314450.png" alt></p><h2 id="接口List"><a href="#接口List" class="headerlink" title="接口List"></a>接口List</h2><p>接口List结构：</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302110651359.png" alt="image-20230302110651359"></p><p>接口内部提供的方法主要是对数据进行增删改查操作。</p><p>接口List对接口Collection进行了扩展，允许根据索引位置操作数据，并且允许内容重复。</p><p>接口List最常用的非并发实现类是ArrayList，它是非线程安全的，可以对数据以链表的形式进行组织，使数据呈现有序的结果。</p><p>类ArrayList不是线程安全的，如果想使用线程安全的链表则可以使用Vector类。</p><p>Vector类是线程安全的，所以在多线程并发操作时可以无误地处理集合中的数据。</p><blockquote><p>多个线程分别调用类Vector的iterator()方法返回Iterator对象，在调用remove()时会出现ConcurrentModificationException异常，也就是说并不支持Iterator并发删除。</p></blockquote><p>类Vector有一个子类Stack，它可以实现后进先出(LIFO)的对象堆栈。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302111744610.png" alt="image-20230302111744610"></p><h2 id="接口Set"><a href="#接口Set" class="headerlink" title="接口Set"></a>接口Set</h2><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302111910179.png" alt="image-20230302111910179"></p><p>接口Set也是对接口Collection进行了扩展，特点是不允许内容重复，排序方式为自然排序。</p><p>其防止元素重复的原理是需要重写hashCode()和equals()方法。</p><p>接口Set最常用的非并发实现类是HashSet。HashSet默认以无序的方式组织元素，LinkedHash—Set类可以有序地组织元素。</p><p>接口Set还有另外一个实现类，即TreeSet。它不仅实现了接口Set，还实现了接口SorteSet和Navi-gableSet。接口SortedSet的父接口为Set，接口Sorted-Set和接口NavigableSet在功能上得到了扩展。</p><h2 id="接口Queue"><a href="#接口Queue" class="headerlink" title="接口Queue"></a>接口Queue</h2><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302113139097.png" alt="image-20230302113139097"></p><p>接口Queue对接口Collection进行了扩展。</p><p>接口Queue的非并发实现类有PriorityQueue，它是一个基于优先级的无界优先级队列。</p><h2 id="接口Deque"><a href="#接口Deque" class="headerlink" title="接口Deque"></a>接口Deque</h2><p>接口Queue支持对表头的操作，而接口Deque不仅支持对表头的操作，而且支持对表尾的操作，所以Deque的全称为Double Ended Queue(双端队列)。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302114605378.png" alt="image-20230302114605378"></p><p>Deque继承了Queue。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302114633944.png" alt="image-20230302114633944"></p><p>接口Deque的非并发实现类有ArrayDeque和LinkedList。它们之间有一些区别：如果只想从队列两端获取数据，则使用ArrayDeque；如果想从队列两端获取数据的同时还可以根据索引的位置操作数据，则使用LinkedList。</p><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><p>非阻塞队列的特色是队列里面没有数据时，返回异常或null。</p><p>在JDK的并发包中，常见的非阻塞队列有：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque、CopyOnWrite-ArrayList、CopyOnWriteArraySet。    </p><h3 id="类ConcurrentHashMap的使用"><a href="#类ConcurrentHashMap的使用" class="headerlink" title="类ConcurrentHashMap的使用"></a>类ConcurrentHashMap的使用</h3><p>类ConcurrentHashMap是支持并发操作的Map对象。</p><p>HashMap不是线程安全的，不能被多个线程操作。</p><p>HashTable类支持多线程环境下的put添加操作，却不支持remove删除操作，但ConcurrentHashMap支持这两个操作。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302160342173.png" alt="image-20230302160342173"></p><h4 id="ConcurrentHashMap并发put"><a href="#ConcurrentHashMap并发put" class="headerlink" title="ConcurrentHashMap并发put"></a>ConcurrentHashMap并发put</h4><p>创建类MyService3：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302160904453.png" alt="image-20230302160904453"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建Test3：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302160938281.png" alt="image-20230302160938281"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302161013946.png" alt="image-20230302161013946"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>可以看到类ConcurrentHashMap支持在多线程环境中执行put操作。</p><h4 id="ConcurrentHashMao并发remove"><a href="#ConcurrentHashMao并发remove" class="headerlink" title="ConcurrentHashMao并发remove"></a>ConcurrentHashMao并发remove</h4><p>创建类MyService5：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302161240016.png" alt="image-20230302161240016"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建类Test5</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302161331723.png" alt="image-20230302161331723"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302161502302.png" alt="image-20230302161502302"></p><p>可以看到类ConcurrentHashMap在功能上比HashTable更加完善，支持并发情况下的put和remove操作。</p><p>类ConcurrentHashMap不支持排序，类LinkedHashMap支持key排序，但不支持并发。</p><p>如果既要求并发安全，又要求排序的情况，可以使用ConcurrentSkipListMap。</p><h3 id="类ConcurrentSkipListMap"><a href="#类ConcurrentSkipListMap" class="headerlink" title="类ConcurrentSkipListMap"></a>类ConcurrentSkipListMap</h3><p>类ConcurrentSkipListMap支持排序</p><p>创建类Userinfo：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302215208184.png" alt="image-20230302215208184"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建类MyService:</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302215247786.png" alt="image-20230302215247786"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建线程类MyThread：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302215322694.png" alt="image-20230302215322694"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>创建类Test：</p><div class="table-container"><table><thead><tr><th><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302215423508.png" alt="image-20230302215423508"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>运行结果：</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230302215455628.png" alt="image-20230302215455628"></p><p>控制台打印出null值时是使用pollFirstEntry()方法将当前的Entry对象从类ConcurrentSkipListMap中删除造成的。</p><h3 id="类ConcurrentSkipListSet"><a href="#类ConcurrentSkipListSet" class="headerlink" title="类ConcurrentSkipListSet"></a>类ConcurrentSkipListSet</h3><p>类ConcurrentSkipListSet支持排序且不允许元素重复。</p><h3 id="类ConcurrentLinkedQueue"><a href="#类ConcurrentLinkedQueue" class="headerlink" title="类ConcurrentLinkedQueue"></a>类ConcurrentLinkedQueue</h3><p>类ConcurrentLinkedQueue提供了并发环境下的队列操作。</p><h3 id="类ConcurrentLinkedDeque"><a href="#类ConcurrentLinkedDeque" class="headerlink" title="类ConcurrentLinkedDeque"></a>类ConcurrentLinkedDeque</h3><p>类ConcurrentLinkedQueue仅支持对列头进行操作，类ConcurrentLinkedDeque支持对列头和列尾双向进行操作。</p><h3 id="类CopyOnWriteArrayList"><a href="#类CopyOnWriteArrayList" class="headerlink" title="类CopyOnWriteArrayList"></a>类CopyOnWriteArrayList</h3><p>并发环境下线程安全，有序。</p><h3 id="类CopyOnWriteArraySet"><a href="#类CopyOnWriteArraySet" class="headerlink" title="类CopyOnWriteArraySet"></a>类CopyOnWriteArraySet</h3><p>替代HashSet，解决多线程环境下线程安全，无序。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>JDK提供的若干集合具有阻塞特性。所谓的阻塞队列BlockingQueue， 其实就是如果BlockQueue是空的，从BlockingQueue中取数据的操作将会被阻塞，进入等待状态，直到BlockingQueue中添加了元素才会被唤醒。同样，如果BlockingQueue是满的，也就是没有空余空间，试图往队列中存放元素的操作也会被阻塞，进入等待状态，直到BlockingQueue有剩余空间时才会被唤醒。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230303093419713.png" alt="image-20230303093419713"></p><p>接口BlockingQueue的父接口是Queue。</p><h3 id="类ArrayBlockingQueue与公平-非公平锁的使用"><a href="#类ArrayBlockingQueue与公平-非公平锁的使用" class="headerlink" title="类ArrayBlockingQueue与公平/非公平锁的使用"></a>类ArrayBlockingQueue与公平/非公平锁的使用</h3><p>类ArrayBlockingQueue提供了一种有界阻塞队列。</p><p><img src="/2023/03/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20230303094034289.png" alt="image-20230303094034289"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程组</title>
      <link href="/2023/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84/"/>
      <url>/2023/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h1><p>为了方便对某些具有相同功能的线程进行管理，我们可以把线程归属到某一个线程组。线程组中可以有线程对象、线程，类似于树的形式。</p><p><img src="/2023/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84/image-20230301213316528.png" alt="image-20230301213316528"></p><p>线程组的作用是可以批量地管理线程或线程对象，有效地对线程或线程对象进行组织。</p><h2 id="一级关联"><a href="#一级关联" class="headerlink" title="一级关联"></a>一级关联</h2><p>所谓的一级关系就是父对象中有子对象，但并不创建子孙对象，这种情况经常出现在开发中。</p><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;ThreadName=&quot;</span> + </span><br><span class="line">Thread.currentThread().</span><br><span class="line">getName());</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;ThreadName=&quot;</span> + </span><br><span class="line">Thread.currentThread().</span><br><span class="line">getName());</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">aRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line"><span class="type">ThreadB</span> <span class="variable">bRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;wuhaodong的线程组&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">aThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, aRunnable);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">bThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, bRunnable);</span><br><span class="line">aThread.start();</span><br><span class="line">bThread.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;活动的线程数为：&quot;</span> + group.activeCount());</span><br><span class="line">System.out.println(<span class="string">&quot;线程组的名称为：&quot;</span> + group.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="/2023/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84/image-20230301213907237.png" alt="image-20230301213907237"></p><h2 id="多级关联："><a href="#多级关联：" class="headerlink" title="多级关联："></a>多级关联：</h2><p>所谓的多级关联就是父对象中有子对象，子对象中再创建子对象，也就是出现了子孙对象。但是，此种写法在开发中不常见。设计非常复杂的线程树结构不利于线程对象的管理，但JDK支持多级关联的线程树结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main组中添加一个线程组A，然后在这个A组中添加线程对象Z</span></span><br><span class="line"><span class="comment">// 方法activeGroupCount()和activeCount()的值不是固定的</span></span><br><span class="line"><span class="comment">// 是系统中环境的一个快照</span></span><br><span class="line"><span class="type">ThreadGroup</span> <span class="variable">mainGroup</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line"><span class="type">ThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(mainGroup, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;runMethod!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);<span class="comment">// 线程必须在运行状态才可以受组管理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">newThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, runnable);</span><br><span class="line">newThread.setName(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">newThread.start();<span class="comment">// 线程必须启动然后才归到组A中</span></span><br><span class="line"><span class="comment">// ///</span></span><br><span class="line">ThreadGroup[] listGroup = <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>[Thread.currentThread()</span><br><span class="line">.getThreadGroup().activeGroupCount()];</span><br><span class="line">Thread.currentThread().getThreadGroup().enumerate(listGroup);</span><br><span class="line">System.out.println(<span class="string">&quot;main线程中有多少个子线程组：&quot;</span> + listGroup.length + <span class="string">&quot; 名字为：&quot;</span></span><br><span class="line">+ listGroup[<span class="number">0</span>].getName());</span><br><span class="line">Thread[] listThread = <span class="keyword">new</span> <span class="title class_">Thread</span>[listGroup[<span class="number">0</span>].activeCount()];</span><br><span class="line">listGroup[<span class="number">0</span>].enumerate(listThread);</span><br><span class="line">System.out.println(listThread[<span class="number">0</span>].getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="/2023/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84/image-20230301214600792.png" alt="image-20230301214600792"></p><h2 id="自动归属特性"><a href="#自动归属特性" class="headerlink" title="自动归属特性"></a>自动归属特性</h2><p>自动归属就是自动归到当前线程组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A处线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 中有线程组数量：&quot;</span>+Thread.currentThread().getThreadGroup().activeGroupCount());</span><br><span class="line">ThreadGroup group=<span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;新的组&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;A处线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 中有线程组数量：&quot;</span>+Thread.currentThread().getThreadGroup().activeGroupCount());</span><br><span class="line">ThreadGroup[] threadGroup=<span class="keyword">new</span> <span class="title class_">ThreadGroup</span>[Thread.currentThread().getThreadGroup().activeGroupCount()];</span><br><span class="line">Thread.currentThread().getThreadGroup().enumerate(threadGroup);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadGroup.length; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;第一个线程组名称为：&quot;</span>+threadGroup[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84/image-20230301220430931.png" alt="image-20230301220430931"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动内存管理</title>
      <link href="/2023/02/27/JVM/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/02/27/JVM/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域。</p><p><img src="/2023/02/27/JVM/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbmRzb21lX0xlX2xl,size_16,color_FFFFFF,t_70.jpeg" alt="在这里插入图片描述"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 </p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。 </p><h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 </p><p>float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 </p><p>局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><p><img src="/2023/02/27/JVM/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/0030ce3cbaa7c7a628416766ae77a8cd.png" alt="image-20200705205443993"></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块线程共享区域，在虚拟机启动时创建。</p><p>此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的内存区域，它也被称作“GC堆”。</p><p>通过参数-Xmx和-Xms设定Java堆大小。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常</p><h2 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</p><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><p>但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</p><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</li></ul><p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。 </p><p>然后Java虚拟机还要对对象进行一些设置，如该对象是那个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/"/>
      <url>/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁从乐观和悲观的角度可分为乐观锁和悲观锁，从获取资源的公平性角度可分为公平锁和非公平锁，从是否共享资源的角度可分为共享锁和独占锁，从锁的状态可分为偏向锁、轻量级锁和重量级锁。JVM中还有自旋锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁，但在更新时会判断再在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法。</p><blockquote><p>具体过程为：比较当前版本号与上一次版本号，如果版本号一致，则更新，如果版本号不一致，则重复进行读，比较，写操作。</p></blockquote><p>Java中的乐观锁大部分是通过CAS（Compare And Swap，比较和交换）操作实现的，CAS是一种原子更新操作，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁采用悲观思想处理数据，在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会上锁，这样别人想读写这个数据时就会阻塞，等待直到拿到锁。</p><p>Java中的悲观锁大部分基于AQS（Abstract Queued Synchronized，抽象的队列同步器）架构实现。AQS定义了一套多线程访问共享资源的同步框架，许多同步类的实现都依赖于它，例如常用的Synchronized、ReentrantLock、Semaphore、CountDownLatch等。该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到，则会转为悲观锁（如RetreenLock）。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁认为：如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等一等（也叫自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核态的切换上导致的锁时间消耗。</p><blockquote><p>线程在自旋时会占用CPU，在线程长时间自旋获取不到锁时，将会产生CPU的浪费，甚至有时线程永远无法获取锁导致CPU资源被永久占用，所以需要设定一个自旋等待的最大时间。在线程执行的时间超过自旋等待的最大时间后，线程会退出自旋模式并释放其持有的锁。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>自旋锁可以减少CPU上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说性能大幅度提升，因为自旋的CPU耗时明显少于线程阻塞、挂起、再唤醒时两次CPU上下文切换所用的时间。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在持有锁的线程占用锁时间过长或锁的竞争过于激烈时，线程在自旋过程中会长时间获取不到锁资源，将引起CPU的浪费。所以在系统中有复杂锁依赖的情况下不适合采用自旋锁。</p><h4 id="时间阈值"><a href="#时间阈值" class="headerlink" title="时间阈值"></a>时间阈值</h4><p>JDK的不同版本所采用的自旋周期不同，JDK1.5为固定的时间，JDK1.6引入了适应性自旋锁。适应性自旋锁的自选时间不再是固定值，而是由上一次在 同一个锁上的自旋时间及锁的拥有者的状态来决定的，可基本认为一个线程上下文切换的时间就是一个最佳时间。</p><h2 id="ReentrantLock类"><a href="#ReentrantLock类" class="headerlink" title="ReentrantLock类"></a>ReentrantLock类</h2><p>jdk1.5中新增，具有嗅探锁定、多路分支通知等功能。</p><h3 id="实现同步"><a href="#实现同步" class="headerlink" title="实现同步"></a>实现同步</h3><p>创建线程类MyThread：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(MyService service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.testMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建MyService类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ThreadName=&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ (<span class="string">&quot; &quot;</span> + (i + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用ReentrantLock对象的lock()方法获取锁，调用unlock()方法释放锁，这两个方法成对使用。想要实现同步代码，把这些代码放在lock()方法和unlock()方法之间即可。</p></blockquote><p>创建启动类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(service);</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(service);</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(service);</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">a4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(service);</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">a5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(service);</span><br><span class="line"></span><br><span class="line">a1.start();</span><br><span class="line">a2.start();</span><br><span class="line">a3.start();</span><br><span class="line">a4.start();</span><br><span class="line">a5.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分运行结果：</p><p><img src="/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/image-20230226210501244.png" alt="image-20230226210501244"></p><p>当前线程打印完毕之后将锁释放，其他线程才可以继续抢锁并打印，每个线程内打印的数据是有序的，即从1到5。因为当前线程已经持有锁，具有互斥排它性，而线程之间打印的顺序是随机的，所以谁抢到锁，谁打印。</p><h3 id="使用方法await-和方法signal-实现wait-notify"><a href="#使用方法await-和方法signal-实现wait-notify" class="headerlink" title="使用方法await()和方法signal()实现wait/notify"></a>使用方法await()和方法signal()实现wait/notify</h3><p>创建MyService类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">&quot; await时间为&quot;</span> + System.currentTimeMillis());</span><br><span class="line">condition.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">&quot;signal时间为&quot;</span> + System.currentTimeMillis());</span><br><span class="line">condition.signal();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(MyService service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.await();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建启动类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(service);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">service.signal();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/image-20230226211817886.png" alt="image-20230226211817886"></p><ul><li>Object类中的wait()方法相当于Condition类中的await()方法。</li><li>Object类中的wait(long timeout)方法相当于Condition类中的await(longtime, TimeUnit unit)方法。</li><li>Object类中的notify()方法相当于Condition类中的signal()方法。</li><li>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</li></ul><h3 id="通知部分线程"><a href="#通知部分线程" class="headerlink" title="通知部分线程"></a>通知部分线程</h3><p>创建MyService类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">awaitA</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">&quot;begin awaitA时间为&quot;</span> + System.currentTimeMillis()</span><br><span class="line">+ <span class="string">&quot; ThreadName=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">conditionA.await();</span><br><span class="line">System.out.println(<span class="string">&quot;  end awaitA时间为&quot;</span> + System.currentTimeMillis()</span><br><span class="line">+ <span class="string">&quot; ThreadName=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">awaitB</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">&quot;begin awaitB时间为&quot;</span> + System.currentTimeMillis()</span><br><span class="line">+ <span class="string">&quot; ThreadName=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">conditionB.await();</span><br><span class="line">System.out.println(<span class="string">&quot;  end awaitB时间为&quot;</span> + System.currentTimeMillis()</span><br><span class="line">+ <span class="string">&quot; ThreadName=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalAll_A</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">&quot;  signalAll_A时间为&quot;</span> + System.currentTimeMillis()</span><br><span class="line">+ <span class="string">&quot; ThreadName=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">conditionA.signalAll();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalAll_B</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">&quot;  signalAll_B时间为&quot;</span> + System.currentTimeMillis()</span><br><span class="line">+ <span class="string">&quot; ThreadName=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">conditionB.signalAll();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(MyService service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.awaitA();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(MyService service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.awaitB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建启动类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(service);</span><br><span class="line">a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>(service);</span><br><span class="line">b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">b.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">service.signalAll_A();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/image-20230226212615947.png" alt="image-20230226212615947"></p><p>只有线程A被唤醒了，使用Condition对象可以唤醒指定种类的线程，这是控制部分线程行为的便捷方式。</p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>公平锁采用先到先得的策略，每次获取锁之前都会检查队列里面有没有排队等待的线程，没有才会尝试获取锁，如果有就将当前线程追加到队列中。</p><p>非公平锁采用“有机会插队”的策略，一个线程获取锁之前，要先去尝试获取锁，而不是在队列中等待，如果真的获取锁成功，说明线程虽然是后启动的，但先获得了锁，这就是“作弊插队”的效果，如果获取锁没有成功，那么将自身追加到队列中进行等待。</p><h2 id="getHoldCount-方法"><a href="#getHoldCount-方法" class="headerlink" title="getHoldCount()方法"></a>getHoldCount()方法</h2><p>public int getHoldCount()方法的作用是查询“当前线程”保持此锁定的个数，也就是调用lock()方法的次数。</p><h2 id="getQueueLength-方法"><a href="#getQueueLength-方法" class="headerlink" title="getQueueLength()方法"></a>getQueueLength()方法</h2><p>public final int getQueueLength()方法的作用是返回正等待获取此锁线程的估计数，比如有5个线程，1个线程长时间占有锁，那么在调用getQueueLength()方法后的返回值是4，说明有4个线程同时在等待锁的释放。</p><h2 id="getWaitQueueLength-Condition-condition-方法"><a href="#getWaitQueueLength-Condition-condition-方法" class="headerlink" title="getWaitQueueLength(Condition condition)方法"></a>getWaitQueueLength(Condition condition)方法</h2><p>public int getWaitQueueLength(Condition condition)方法的作用是返回等待与此锁相关的给定条件Condition的线程估计数，比如有5个线程，每个线程都执行了同一个Condition对象的await()方法，则调用<br>getWaitQueueLength(Condition condition)方法时返回的int值是5。</p><h2 id="hasQueuedThread-Thread-thread-方法"><a href="#hasQueuedThread-Thread-thread-方法" class="headerlink" title="hasQueuedThread(Thread thread)方法"></a>hasQueuedThread(Thread thread)方法</h2><p>public final boolean hasQueuedThread(Thread thread)方法的作用是查询指定的线程是否正在等待获取此锁，也就是判断参数中的线程是否在等待队列中。</p><h2 id="hasQueuedThreads-方法"><a href="#hasQueuedThreads-方法" class="headerlink" title="hasQueuedThreads()方法"></a>hasQueuedThreads()方法</h2><p>public final boolean hasQueuedThreads()方法的作用是查询是否有线程正在等待获取此锁，也就是等待队列中是否有等待的线程。</p><h2 id="hasWaiters-Condition-condition-方法"><a href="#hasWaiters-Condition-condition-方法" class="headerlink" title="hasWaiters(Condition condition)方法"></a>hasWaiters(Condition condition)方法</h2><p>public boolean hasWaiters(Condition condition)方法的作用是查询是否有线程正在等待与此锁有关的condition对象，也就是是否有线程执行了condition对象中的await()方法而呈等待状态。public int<br>getWaitQueueLength(Condition condition)方法的作用是返回有多少个线程执行了condition对象中的await()方法而呈等待状态。</p><h2 id="isFair-方法"><a href="#isFair-方法" class="headerlink" title="isFair()方法"></a>isFair()方法</h2><p>public final boolean isFair()方法的作用是判断是不是公平锁。</p><h2 id="isHeldByCurrentThread-方法"><a href="#isHeldByCurrentThread-方法" class="headerlink" title="isHeldByCurrentThread()方法"></a>isHeldByCurrentThread()方法</h2><p>public boolean isHeldByCurrentThread()方法的作用是查询当前线程是否持有此锁。</p><h2 id="isLocked-方法"><a href="#isLocked-方法" class="headerlink" title="isLocked()方法"></a>isLocked()方法</h2><p>public boolean isLocked()方法的作用是查询此锁定是否由任意线程持有，且没有释放。</p><h2 id="lockInterruptibly-方法"><a href="#lockInterruptibly-方法" class="headerlink" title="lockInterruptibly()方法"></a>lockInterruptibly()方法</h2><p>public void lockInterruptibly()方法的作用是当某个线程尝试获得锁并且阻塞在lock-Interruptibly()方法时，该线程可以被中断。</p><h2 id="tryLock-方法"><a href="#tryLock-方法" class="headerlink" title="tryLock()方法"></a>tryLock()方法</h2><p>public boolean tryLock()方法的作用是嗅探拿锁，如果当前线程发现锁被其他线程持有了，则返回false，那么程序继续执行后面的代码，而不是呈阻塞等待锁的状态。</p><h2 id="tryLock-long-timeout-TimeUnit-unit-方法"><a href="#tryLock-long-timeout-TimeUnit-unit-方法" class="headerlink" title="tryLock(long timeout, TimeUnit unit)方法"></a>tryLock(long timeout, TimeUnit unit)方法</h2><p>public boolean tryLock(long timeout, TimeUnit unit)方法的作用是嗅探拿锁，如果在指定的timeout内持有了锁，则返回true，如果超过时间则返回false。timeout参数代表当前线程抢锁的时间。</p><h2 id="await-long-time-TimeUnit-unit-方法"><a href="#await-long-time-TimeUnit-unit-方法" class="headerlink" title="await(long time, TimeUnit unit)方法"></a>await(long time, TimeUnit unit)方法</h2><p>public boolean await(long time, TimeUnit unit)方法和public final native void<br>wait(long timeout)方法一样，具有自动唤醒功能。</p><h2 id="awaitNanos-long-nanosTimeout-方法"><a href="#awaitNanos-long-nanosTimeout-方法" class="headerlink" title="awaitNanos(long nanosTimeout)方法"></a>awaitNanos(long nanosTimeout)方法</h2><p>public long awaitNanos(long nanosTimeout)方法和public final native void wait(long timeout)方法一样，具有自动唤醒功能。时间单位是纳秒。1000纳秒等于1微秒，1000微秒等于1毫秒，1000毫秒等于1秒。</p><h2 id="awaitUntil-Date-deadline-方法"><a href="#awaitUntil-Date-deadline-方法" class="headerlink" title="awaitUntil(Date deadline)方法"></a>awaitUntil(Date deadline)方法</h2><p>public boolean awaitUntil(Date deadline)方法的作用是在指定的日期结束等待。</p><h2 id="awaitUninterruptibly-方法"><a href="#awaitUninterruptibly-方法" class="headerlink" title="awaitUninterruptibly()方法"></a>awaitUninterruptibly()方法</h2><p>public void awaitUninterruptibly()方法的作用是等待的过程中，不允许被中断。</p><h2 id="ReentranReadWriteLock类"><a href="#ReentranReadWriteLock类" class="headerlink" title="ReentranReadWriteLock类"></a>ReentranReadWriteLock类</h2><p>类ReentranReadWriteLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentranLock.lock()方法后面的任务。这样虽然保证了实例变量的线程安全性，但效率却是非常低下的。所以在JDK中提供了一种读写锁ReentranReadWriteLock类，使用它可以加快运行效率，在某些不需要操作的实例变量的方法中，完全可以使用读写锁ReentranReadWriteLock来提升该方法的代码运行速度。</p><p>读写锁表示也有两个锁，一个是读操作相关锁，也称为共享锁；另一个是写操作相关的锁，也叫排它锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程Thread进行写入操作时，进行读操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即多个Threa可以同时进行读取操作。</p><h3 id="读读共享"><a href="#读读共享" class="headerlink" title="读读共享"></a>读读共享</h3><p>创建线程类ThreadA：         </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类Service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.readLock().lock();</span><br><span class="line">System.out.println(<span class="string">&quot;获得读锁&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; &quot;</span> + System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(service);</span><br><span class="line">      a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>(service);</span><br><span class="line">      b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">      a.start();</span><br><span class="line">      b.start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/image-20230227142848393.png" alt="image-20230227142848393"></p><p>可以看到两个线程几乎同时进入lock()方法后面的代码。说明在此使用了lock.readLock()读锁可以提高程序运行效率，运行多个线程同时执行lock()方法后面的代码。</p><h3 id="写写互斥"><a href="#写写互斥" class="headerlink" title="写写互斥"></a>写写互斥</h3><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.write();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.write();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类Service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.writeLock().lock();</span><br><span class="line">System.out.println(<span class="string">&quot;获得写锁&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; &quot;</span> + System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(service);</span><br><span class="line">a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>(service);</span><br><span class="line">b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/image-20230227144149082.png" alt="image-20230227144149082"></p><p>同一时间只允许一个线程执行lock()方法后面的代码。</p><h3 id="读写互斥"><a href="#读写互斥" class="headerlink" title="读写互斥"></a>读写互斥</h3><p>修改上面Service类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.readLock().lock();</span><br><span class="line">System.out.println(<span class="string">&quot;readLock&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; &quot;</span> + System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.writeLock().lock();</span><br><span class="line">System.out.println(<span class="string">&quot;writLock&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; &quot;</span> + System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/image-20230227144535130.png" alt="image-20230227144535130"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信</title>
      <link href="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait/notify机制"></a>wait/notify机制</h2><p>wait/notify(等待/通知)机制在如下场景就会出现：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230225105737806.png" alt="image-20230225105737806"></p><ol><li>厨师做完菜的时间未知，所以菜品被放到传递台上的时间也未知。</li><li>服务员去菜的时间取决于厨师，所以服务员进入<strong>wait</strong>状态。</li><li>厨师做好菜，将菜放到传递台就相当于<strong>notify</strong>，这是服务员接到通知来取菜。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>wait()是Object类的方法，它会使当前执行该方法的线程进入等待状态，在该方法所在的代码行处暂停执行，并释放锁，知道接到通知或被中断为止。</p><p>在调用wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步代码块中调用wait()方法。通过通知机制使某个线程继续执行wait()方法后面的代码时，对线程的选择是按着执行wait()方法的顺序确定的，并需要重新获得锁。如果调用wait()方法时没有适当的锁，则抛出IllegalMonitorStateException。它是RuntimeException的一个子类，因此不需要try-catch语句。</p><p>notify()也要在同步方法或同步块中调用，即在调用前线程必须要获得锁，如果调用notify()时没有持有适当的锁，也会抛出IllegalMonitorStateException。该方法用来通知那些可能等待该锁的其他线程，如果有多个线程等待，则按着执行wait()方法的顺序对呈等待状态的线程发出1次通知，并使那个线程重新获取锁。需要说明的是，执行<br>notify()方法后，当前线程不会马上释放该锁，呈等待状态的线程也并不能马上获取该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出同步区域后，当前线程才会释放锁，而呈等待状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的等待线程运行完毕后，它会释放掉该对象锁。此时如果没有再次使用notify语句，那么其他等待状态的线程会因为没有得到通知而继续等待。</p><p>创建线程类MyThread1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread1</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始      wait time=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">lock.wait();</span><br><span class="line">System.out.println(<span class="string">&quot;结束      wait time=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类MyThread2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread2</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始notify time=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">lock.notify();</span><br><span class="line">System.out.println(<span class="string">&quot;结束notify time=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建启动类Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>(lock);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(lock);</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230225120210076.png" alt="image-20230225120210076"></p><h2 id="线程状态切换"><a href="#线程状态切换" class="headerlink" title="线程状态切换"></a>线程状态切换</h2><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230225124559176.png" alt="image-20230225124559176"></p><ul><li>创建一个新的线程对象后，再调用它的start()方法，系统会为此线程分配CPU资源，处于可运行状态，如果线程抢占到CPU资源，此线程就处于运行状态。</li><li>线程运行一段时间后其他高优先级的线程抢占了CPU资源，这时此线程就从运行状态变成可运行状态。</li><li>暂停状态结束后，线程进入可运行状态，等待系统重新分配资源。</li><li>run()方法运行结束后进入销毁阶段，整个线程执行完毕。</li></ul><h3 id="线程进入可运行状态大致分为以下四种情况"><a href="#线程进入可运行状态大致分为以下四种情况" class="headerlink" title="线程进入可运行状态大致分为以下四种情况"></a>线程进入可运行状态大致分为以下四种情况</h3><ol><li>调用sleep()方法后经过的时间超过了指定的休眠时间；</li><li>线程成功获得了试图同步的监视器；</li><li>线程正在等待某个通知，其他线程发出了通知；</li><li>处于挂起状态的线程调用了resume方法。</li></ol><h3 id="出现阻塞的情况大体分为以下五种"><a href="#出现阻塞的情况大体分为以下五种" class="headerlink" title="出现阻塞的情况大体分为以下五种"></a>出现阻塞的情况大体分为以下五种</h3><ol><li>线程调用sleep方法，主动放弃占用的处理器资源；</li><li>线程调用了阻塞式I/O方法，在该方法返回前，该线程被阻塞；</li><li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有；</li><li>线程等待某个通知；</li><li>程序调用了suspend方法将该线程挂起。此方法容易导致死锁，应尽量避免使用。</li></ol><h2 id="生产者-消费者模式实现"><a href="#生产者-消费者模式实现" class="headerlink" title="生产者/消费者模式实现"></a>生产者/消费者模式实现</h2><h3 id="一生产与一消费情况下的操作值"><a href="#一生产与一消费情况下的操作值" class="headerlink" title="一生产与一消费情况下的操作值"></a>一生产与一消费情况下的操作值</h3><p>创建生产者类P：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">P</span><span class="params">(String lock)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ValueObject.value.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">lock.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="string">&quot;_&quot;</span></span><br><span class="line">+ System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;set的值是&quot;</span> + value);</span><br><span class="line">ValueObject.value = value;</span><br><span class="line">lock.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建消费者类C：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">C</span><span class="params">(String lock)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.lock = lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"><span class="keyword">if</span> (ValueObject.value.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">lock.wait();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;get的值是&quot;</span> + ValueObject.value);</span><br><span class="line">ValueObject.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">lock.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建存储值的对象ValueObject类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValueObject</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadC</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> C r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadC</span><span class="params">(C r)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.r = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">r.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类P：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadP</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> P p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadP</span><span class="params">(P p)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.p = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">p.setValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建启动类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">P</span>(lock);</span><br><span class="line"><span class="type">C</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>(lock);</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadP</span> <span class="variable">pThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadP</span>(p);</span><br><span class="line"><span class="type">ThreadC</span> <span class="variable">rThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadC</span>(r);</span><br><span class="line"></span><br><span class="line">pThread.start();</span><br><span class="line">rThread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226193606052.png" alt="image-20230226193606052"></p><p>可以看到1个生产者和1个消费者进行数据的交互，在控制台中打印的get和set时交替运行的。</p><h2 id="在管道中传递字节流"><a href="#在管道中传递字节流" class="headerlink" title="在管道中传递字节流"></a>在管道中传递字节流</h2><p>管道流是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个县城从输入管道中读数据。通过使用管道，实现不同线程间的通信，而不需借助于临时文件。</p><p>创建类WriteData：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteData</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeMethod</span><span class="params">(PipedOutputStream out)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;write :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">outData</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + (i + <span class="number">1</span>);</span><br><span class="line">out.write(outData.getBytes());</span><br><span class="line">System.out.print(outData);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">out.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类ReadData：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadData</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readMethod</span><span class="params">(PipedInputStream input)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;read  :&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] byteArray = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> input.read(byteArray);</span><br><span class="line"><span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">System.out.print(newData);</span><br><span class="line">readLength = input.read(byteArray);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">input.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadRead：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadRead</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ReadData read;</span><br><span class="line"><span class="keyword">private</span> PipedInputStream input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadRead</span><span class="params">(ReadData read, PipedInputStream input)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.read = read;</span><br><span class="line"><span class="built_in">this</span>.input = input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">read.readMethod(input);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadWrite：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadWrite</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WriteData write;</span><br><span class="line"><span class="keyword">private</span> PipedOutputStream out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadWrite</span><span class="params">(WriteData write, PipedOutputStream out)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.write = write;</span><br><span class="line"><span class="built_in">this</span>.out = out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">write.writeMethod(out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">WriteData</span> <span class="variable">writeData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteData</span>();</span><br><span class="line"><span class="type">ReadData</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadData</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">PipedInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line"><span class="type">PipedOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// inputStream.connect(outputStream);</span></span><br><span class="line">outputStream.connect(inputStream);</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadRead</span> <span class="variable">threadRead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadRead</span>(readData, inputStream);</span><br><span class="line">threadRead.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadWrite</span> <span class="variable">threadWrite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadWrite</span>(writeData, outputStream);</span><br><span class="line">threadWrite.start();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码inputStream.connect(outputStream)或outputStream.connect(inputStream)的作用是使两个管道之间产生通信链接，这样才可以将数据进行输出与输入。</p></blockquote><p>运行结果：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226195105124.png" alt="image-20230226195105124"></p><p>在此实验中，首先是读取线程new ThreadRead(inputStream)先启动，由于当时没有数据被写入，所以线程阻塞在int readLength =in.read(byteArray);代码中，直到有数据被写入，才继续向下运行。</p><h2 id="利用wait-notify机制实现交叉备份"><a href="#利用wait-notify机制实现交叉备份" class="headerlink" title="利用wait/notify机制实现交叉备份"></a>利用wait/notify机制实现交叉备份</h2><p>创建20个线程，其中10个线程是将数据备份到A数据库中，另外10个线程将数据备份到B数据库中，并且两个数据库的备份工作是交叉进行的。</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226195628805.png" alt="image-20230226195628805"></p><p>先创建20个线程，然后将这20个线程编程有序的，如下所示</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226195710629.png" alt="image-20230226195710629"></p><p>创建类DBTools：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBTools</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">prevIsA</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backupA</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (prevIsA == <span class="literal">true</span>) &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;★★★★★&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">prevIsA = <span class="literal">true</span>;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backupB</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (prevIsA == <span class="literal">false</span>) &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;☆☆☆☆☆&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">prevIsA = <span class="literal">false</span>;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量prevIsA的主要作用就是确保备份“★★★★★”数据库A首先执行，然后与“☆☆☆☆☆”数据库B交替进行备份。</p></blockquote><p>创建线程类BackupA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackupA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DBTools dbtools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BackupA</span><span class="params">(DBTools dbtools)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.dbtools = dbtools;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">dbtools.backupA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类BackupB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackupB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DBTools dbtools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BackupB</span><span class="params">(DBTools dbtools)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.dbtools = dbtools;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">dbtools.backupB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">DBTools</span> <span class="variable">dbtools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBTools</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">         <span class="type">BackupB</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BackupB</span>(dbtools);</span><br><span class="line">         output.start();</span><br><span class="line">         <span class="type">BackupA</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BackupA</span>(dbtools);</span><br><span class="line">         input.start();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分运行结果如下：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226200221731.png" alt="image-20230226200221731"></p><p>交替打印的原理就是使用如下代码作为标记实现A和B线程交替备份的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">prevIsA</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="方法sleep-和wait-的区别"><a href="#方法sleep-和wait-的区别" class="headerlink" title="方法sleep()和wait()的区别"></a>方法sleep()和wait()的区别</h2><ul><li>sleep()是Thread类中的方法，而wait()是Object类中的方法。</li><li>sleep()可以不结合synchronized使用，而wait()必须结合。</li><li>sleep()在执行时不会释放锁，而wait()在执行后锁被释放了。</li><li>sleep()方法执行后线程的状态是TIMED_WAITING，wait()方法执行后线程的状态是等待。</li></ul><h2 id="方法join"><a href="#方法join" class="headerlink" title="方法join()"></a>方法join()</h2><p>主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束，这时如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，这个时候就要用到join()方法了。方法join()的作用是等待线程对象销毁。</p><p>创建类MyThread：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">secondValue</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">System.out.println(secondValue);</span><br><span class="line">Thread.sleep(secondValue);</span><br><span class="line">System.out.println(<span class="string">&quot;睡眠结束！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">threadTest.start();</span><br><span class="line">threadTest.join();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;我想当threadTest对象执行完毕后我再执行，我做到了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226201347990.png" alt="image-20230226201347990"></p><p>方法join()的作用是使所属的线程对象x正常执行run()方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。也就是说，join()方法具有串联执行的作用：你不销毁，我不往下走！</p><h2 id="ThreadLocal类的使用"><a href="#ThreadLocal类的使用" class="headerlink" title="ThreadLocal类的使用"></a>ThreadLocal类的使用</h2><p>类ThreadLocal主要的作用就是将数据放入当前线程对象中的Map里，这个Map是Thread类的实例变量。类ThreadLocal自己不管理也不存储任何数据，它只是数据和Map之间的中介和桥梁，通过ThreadLocal将数据放入<br>Map中，执行流程如下：</p><p><strong>数据-&gt;ThreadLocal-&gt;currentThread()-&gt;Map</strong></p><p>执行后每个线程中的Map就存有自己的数据，Map中的key存储的是ThreadLocal对象，value就是存储的值，说明ThreadLocal和值之间是一对一的关系，一个ThreadLocal对象只能关联一个值。每个线程中Map的值只对当前线程可见，其他线程不可以访问当前线程对象中Map的值。</p><p>内存结果如下所示：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226202913000.png" alt="image-20230226202913000"></p><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Tools.tl.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">Tools.tl.set(<span class="string">&quot;ThreadA&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ThreadA get Value=&quot;</span> + Tools.tl.get());</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Tools.tl.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">Tools.tl.set(<span class="string">&quot;ThreadB&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ThreadB get Value=&quot;</span> + Tools.tl.get());</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Tools类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tools</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ThreadLocal</span> <span class="variable">tl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建启动类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line"><span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Tools.tl.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">Tools.tl.set(<span class="string">&quot;Main&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Main get Value=&quot;</span> + Tools.tl.get());</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230226204346247.png" alt="image-20230226204346247"></p><p>控制台输出的结果表明通过ThreadLocal向每一个线程存储自己的私有数据，虽然3个线程都向tl对象中通过的set()存放数据值，但每个线程仅能取出自己的数据，不能取出别人的。</p><h2 id="验证线程变量的隔离性"><a href="#验证线程变量的隔离性" class="headerlink" title="验证线程变量的隔离性"></a>验证线程变量的隔离性</h2><p>创建ThreadLocalExt类继承ThreadLocal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExt</span> <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;在ThreadA线程中取值=&quot;</span> + Tools.tl.get());</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Tools类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tools</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ThreadLocalExt</span> <span class="variable">tl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalExt</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;       在Main线程中取值=&quot;</span> + Tools.tl.get());</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">a.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230227094608927.png" alt="image-20230227094608927"></p><p>子线程和父线程各有各的值</p><h3 id="InheritableThreadLocal类的使用"><a href="#InheritableThreadLocal类的使用" class="headerlink" title="InheritableThreadLocal类的使用"></a>InheritableThreadLocal类的使用</h3><p>使用类InheritableThreadLocal可以在子线程中取得父线程继承下来的值。</p><h4 id="值继承"><a href="#值继承" class="headerlink" title="值继承"></a>值继承</h4><p>将上面继承ThreadLocal类的ThreadLocalExt类，改为继承InheritableThreadLocal类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalExt</span> <span class="keyword">extends</span> <span class="title class_">InheritableThreadLocal</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230227095010970.png" alt="image-20230227095010970"></p><h4 id="值继承再修改"><a href="#值继承再修改" class="headerlink" title="值继承再修改"></a>值继承再修改</h4><p>在继承的同时追加内容</p><p>在ThreadLocalExt类中增加成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Object childValue(Object parentValue) &#123;</span><br><span class="line">return parentValue + &quot; 我在子线程加的~!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20230227133748584.png" alt="image-20230227133748584"></p><blockquote><p>如果在子线程取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取得的值还是旧值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程通信 </tag>
            
            <tag> 线程状态切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized关键字</title>
      <link href="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><p>synchronized关键字用于为Java对象、方法、代码块提供线程安全的操作。</p><p>synchronized属于独占式的悲观锁，同时属于可重入锁。</p><h2 id="Synchronized在字节码中的原理"><a href="#Synchronized在字节码中的原理" class="headerlink" title="Synchronized在字节码中的原理"></a>Synchronized在字节码中的原理</h2><p>在synchronized内部包括ContentionList、EntryList、WaitSet、OnDeck、Owner、!Owner 6个区域，每个区域都代表锁的不同状态。</p><ul><li>ContentionList：锁竞争队列，所有请求锁的线程都被放在竞争队列中。</li><li>EntryList：竞争候选列表，在Contention List中有资格成为候选者来竞争锁资源的线程被移动到了Entry List中。</li><li>WaitSet：等候集合，在调用wait方法后被阻塞的线程将被放在WaitSet中。</li><li>OnDeck：竞争候选者，在同一时刻最多只有一个线程在竞争锁资源，该线程的状态被称为OnDeck。</li><li>Owner：竞争到锁资源的线程被称为Owner状态线程。</li><li>!Owner：在Owner线程释放锁后，会从Owner的状态变成!Owner。</li></ul><p>synchronized在收到新的锁请求时首先自旋，如果通过自旋也没有获取锁资源，则将被放入锁竞争队列ContentionList中。</p><p>为了防止锁竞争时ContentionList尾部的元素被大量的并发线程进行CAS访问而影响性能，Owner线程会在释放锁资源时将ContentionList中的部分线程移动到EntryList中，并指定EntryList中的某个线程（一般是最先进入的线程）为OnDeck线程。Owner线程并没有直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，让OnDeck线程重新竞争锁。在Java中把该行为成为“竞争切换”，该行为牺牲了公平性，但提高了性能。</p><p>获取到锁资源的OnDeck线程会变成为Owner线程，而未获取到锁资源的线程仍然停留在EntryList中。</p><p>Owner线程在被wait方法阻塞后，会被转移到WaitSet队列中，直到某个时刻被notify方法或者notifyAll方法唤醒，会再次进入EntryList中。ContentionList、EntryList、WaitSet中的线程均为阻塞状态，该阻塞是由操作系统来完成的（在Linux内核下是采用pathread_mutex_lock内核函数实现的）。</p><p>Owner线程在执行完毕后会释放锁的资源并变为!Owner状态。</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230309170805427.png" alt="image-20230309170805427"></p><p>在synchronized中，在线程进入ContentionList之前，等待的线程会先尝试以自旋的方式获取锁，如果获取不到就进入ContentionList，该做法对于已经进入队列的线程是不公平的，因此synchronized是非公平锁。另外，自旋获取锁的线程也可以直接抢占OnDeck线程的锁资源。</p><p>synchronized是一个重量级操作，需要调用操作系统的相关接口，性能较低，给线程加锁的时间有可能超过获取锁后具体逻辑代码的操作时间。</p><p>JDK1.6对synchronized做了很多优化，引入了适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等以提高锁的效率。锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程称为锁膨胀。在JDK1.6中默认开启了偏向锁和轻量级锁，可以通过<strong>-XX:UseBiasedLocking</strong>禁用偏向锁。</p><p>在方法上使用synchronized关键字实现同步的原因是使用了flag标记ACC_SYNCHRONIZED，当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。</p><h3 id="在方法中使用Synchronized关键字"><a href="#在方法中使用Synchronized关键字" class="headerlink" title="在方法中使用Synchronized关键字"></a>在方法中使用<strong>Synchronized</strong>关键字</h3><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedStudy</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">synMethod</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        synMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令<strong>javap -c -v SynchronizedStudy.class</strong>将class文件转为字节码指令</p><blockquote><p>参数-v表示输出附加信息</p><p>参数-c表示对代码进行反汇编</p></blockquote><p>生成的字节码指令核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synMethod</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method synMethod:()V</span></span><br><span class="line">       <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">3</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">4</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>可以看到synMethod()方法使用flag标记<strong>ACC_SYNCHRONIZED</strong>，说明该方法是同步的。</p><h3 id="在代码块中使用Synchronized关键字"><a href="#在代码块中使用Synchronized关键字" class="headerlink" title="在代码块中使用Synchronized关键字"></a>在代码块中使用Synchronized关键字</h3><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;氵告 东&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedStudy</span> <span class="variable">synchronizedStudy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedStudy</span>();</span><br><span class="line">        synchronizedStudy.method();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令<strong>javap -c -v SynchronizedStudy.class</strong>生成字节码指令，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String 氵告 东</span></span><br><span class="line">       <span class="number">6</span>: astore_2</span><br><span class="line">       <span class="number">7</span>: aload_1</span><br><span class="line">       <span class="number">8</span>: monitorexit</span><br><span class="line">       <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">      <span class="number">12</span>: astore_3</span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      <span class="number">14</span>: monitorexit</span><br><span class="line">      <span class="number">15</span>: aload_3</span><br><span class="line">      <span class="number">16</span>: athrow</span><br><span class="line">      <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由代码可以看到使用了<strong>monitorenter</strong>和<strong>monitorexit</strong>指令进行同步处理。</p><h2 id="synchronized方法将对象作为锁"><a href="#synchronized方法将对象作为锁" class="headerlink" title="synchronized方法将对象作为锁"></a>synchronized方法将对象作为锁</h2><p>创建如下代码：</p><p>MyObject类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;begin methodA threadName=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName());</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程类TA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> MyObject object;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TA</span><span class="params">(MyObject object)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.object = object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.run();</span><br><span class="line">object.methodA();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程类TB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> MyObject object;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TB</span><span class="params">(MyObject object)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.object = object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.run();</span><br><span class="line">object.methodA();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="type">TA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TA</span>(object);</span><br><span class="line">a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">TB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TB</span>(object);</span><br><span class="line">b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224003404885.png" alt="image-20230224003404885"></p><p>可以看到两个线程一起进入方法methodA()，因为该方法没有同步化。</p><p>为MyObject类中methodA()方法添加<strong>synchronized</strong>关键字如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;begin methodA threadName=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName());</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出结果为：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224003826022.png" alt="image-20230224003826022"></p><p>由此可见，调用关键字<strong>synchronized</strong>声明的方法一定是排队运行。并且，只有资源共享的写访问才需要同步化，否则没有同步的必要。</p><h3 id="将对象作为锁"><a href="#将对象作为锁" class="headerlink" title="将对象作为锁"></a>将对象作为锁</h3><p>创建类MyObjectTwo，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObjectTwo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;begin methodA threadName=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName());</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;end endTime=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;begin methodB threadName=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName() + <span class="string">&quot; begin time=&quot;</span></span><br><span class="line">+ System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个自定义线程类分别调用不同方法：</p><p>TAtwo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TAtwo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyObjectTwo object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TAtwo</span><span class="params">(MyObjectTwo object)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.object = object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.run();</span><br><span class="line">object.methodA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TBtwo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TBtwo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyObjectTwo object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TBtwo</span><span class="params">(MyObjectTwo object)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.object = object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.run();</span><br><span class="line">object.methodB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行方法RunTwo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunTwo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyObjectTwo</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObjectTwo</span>();</span><br><span class="line"><span class="type">TAtwo</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TAtwo</span>(object);</span><br><span class="line">a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">TBtwo</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TBtwo</span>(object);</span><br><span class="line">b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224010046517.png" alt="image-20230224010046517"></p><p>线程A先持有了object对象的锁，但线程B完全可以异步调用非synchronized类型的方法。</p><p>将MyObjectTwo类中的methodB()方法前加入synchronized关键字，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;begin methodB threadName=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName() + <span class="string">&quot; begin time=&quot;</span></span><br><span class="line">+ System.currentTimeMillis());</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224010313154.png" alt="image-20230224010313154"></p><h4 id="结论如下："><a href="#结论如下：" class="headerlink" title="结论如下："></a>结论如下：</h4><ul><li>A线程先持有object对象的锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。</li><li>A线程先持有object对象的锁，B线程如果在这时调用object对象中的synchronized类型的方法，则需等待，也就是同步。</li><li>在方法声明处添加synchronized并不是锁方法，而是锁当前类的对象。</li><li>在Java中只有将对象作为锁，并没有锁方法这种说法。</li><li>在Java语言中，锁就是对象，对象可以映射成锁，哪个线程拿到这把锁，哪个线程就可以执行这个对象中的synchronized同步方法。</li><li>如果在X对象中使用了synchronized关键字声明非静态方法，则X对象就被当成锁。</li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>发生脏读的原因是在读取实例变量时，值被其他线程已经更改过了。</p><p>创建类PublicVar，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublicVar</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;AA&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.username = username;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"><span class="built_in">this</span>.password = password;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;setValue method thread name=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName() + <span class="string">&quot; username=&quot;</span></span><br><span class="line">+ username + <span class="string">&quot; password=&quot;</span> + password);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;getValue method thread name=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName() + <span class="string">&quot; username=&quot;</span> + username</span><br><span class="line">+ <span class="string">&quot; password=&quot;</span> + password);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> PublicVar publicVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(PublicVar publicVar)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.publicVar = publicVar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.run();</span><br><span class="line">publicVar.setValue(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">PublicVar</span> <span class="variable">publicVarRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PublicVar</span>();</span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(publicVarRef);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">20</span>);<span class="comment">// 打印结果受此值大小影响</span></span><br><span class="line"></span><br><span class="line">publicVarRef.getValue();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224100432526.png" alt="image-20230224100432526"></p><p>Thread-0线程执行run方法，调用setValue()方法，在setUserName后，线程进入睡眠，但还没有setPassword，所以password的值为默认值AA，但main线程异步开始调用getValue()方法，所以出现脏读现象。</p><p>解决办法是在getValue方法上加入synchroinzed关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;getValue method thread name=&quot;</span></span><br><span class="line">+ Thread.currentThread().getName() + <span class="string">&quot; username=&quot;</span> + username</span><br><span class="line">+ <span class="string">&quot; password=&quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224101441715.png" alt="image-20230224101441715"></p><p>可以看到setValue()方法和getValue()方法被依次执行。</p><h4 id="结论如下：-1"><a href="#结论如下：-1" class="headerlink" title="结论如下："></a>结论如下：</h4><ul><li>当A线程调用anyObject对象加入synchronized关键字的X方法时，A线 程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕后 才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方 法。</li><li>当A线程调用anyObject对象加入synchronized关键字的X方法时，A线 程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕后才可以调用X方法，而B线程如果调用声明了synchronized关键字的非X方法 时，必须等A线程将X方法执行完，也就是将对象锁释放后才可以调用， 这时A线程已经执行了一个完整的任务，也就是说username和password这 两个实例变量已经同时被赋值，不存在脏读的基本环境。</li><li>多个线程在调用同一个业务对象中不同的同步方法时，是按顺序同步的方式调用的。</li></ul><h2 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入"></a>synchronized锁重入</h2><p>在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象锁的。</p><p>创建类Service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service1</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service1&quot;</span>);</span><br><span class="line">service2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service2</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service2&quot;</span>);</span><br><span class="line">service3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service3</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>service1()中调用service2(),service2()方法中调用service3()，并且这三个方法都加了synchronized关键字。</p></blockquote><p>创建线程类MyThread：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line">service.service1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Rrun:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224103112377.png" alt="image-20230224103112377"></p><p>”可重入锁“是指自己可以再次获取自己的内部锁，并且锁重入也是支持在父子类继承的环境。当子类继承父类的同步方法时，在子类的同步方法中调用<code>this</code>关键字来调用同名方法时，实际上并不是调用了子类自己的同步方法，而是调用了父类的同步方法，这是因为子类继承了父类的同步方法锁。</p><h3 id="出现异常时，锁会自动释放"><a href="#出现异常时，锁会自动释放" class="headerlink" title="出现异常时，锁会自动释放"></a>出现异常时，锁会自动释放</h3><blockquote><p>Thread类中，suspend()和sleep(millis)方法被调用后并不释放锁。</p></blockquote><h3 id="非同步方法：不使用synchronized重写方法"><a href="#非同步方法：不使用synchronized重写方法" class="headerlink" title="非同步方法：不使用synchronized重写方法"></a>非同步方法：不使用synchronized重写方法</h3><blockquote><p>重写方法如果不适用synchronized关键字，即非同步方法，使用后变成同步方法。</p></blockquote><h2 id="synchronized同步语句块"><a href="#synchronized同步语句块" class="headerlink" title="synchronized同步语句块"></a>synchronized同步语句块</h2><blockquote><p>synchronized方法是将当前对象作为锁，而synchronized代码块是将任意对象作为锁。锁可以认为是一个标识，持有这个标识的线程就可以执行被同步的代码。</p><p>当使用一个线程访问object的一个synchronized(this)同步代码块时，其他线程对同一个object中所有其他synchronized(this)同步代码块的访问将被阻塞，说synchronized使用的锁是一个。</p></blockquote><h3 id="方法println-也是同步的"><a href="#方法println-也是同步的" class="headerlink" title="方法println()也是同步的"></a>方法println()也是同步的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将任意对象作为锁"><a href="#将任意对象作为锁" class="headerlink" title="将任意对象作为锁"></a>将任意对象作为锁</h2><p>synchronized（非this对象x）同步代码块的执行特性如下：在多个线程争抢相同的非this对象x的锁时，同一时间只有一个线程可以执行synchronized（非this对象x）同步代码块中的代码。</p><p>创建Service类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String usernameParam;</span><br><span class="line"><span class="keyword">private</span> String passwordParam;</span><br><span class="line"><span class="type">String</span> <span class="variable">anyString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsernamePassword</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (anyString) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;在&quot;</span> + Instant.now() + <span class="string">&quot;进入同步块&quot;</span>);</span><br><span class="line">usernameParam = username;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">passwordParam = password;</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;在&quot;</span> + Instant.now() + <span class="string">&quot;离开同步块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.setUsernamePassword(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.setUsernamePassword(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Run:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(service);</span><br><span class="line">a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>(service);</span><br><span class="line">b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">b.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224115113213.png" alt="image-20230224115113213"></p><p>锁非this对象具有一定的优点，就是如果一个类中有很多synchronized方法，这时虽然能实现同步，但影响运行效率，如果使用同步代码块锁非this对象，则synchronized（非this）代码块中的程序与同步方法是异步的， 因为是两把锁，不与其他锁this同步方法争抢this锁，可大大提高运行效率。</p><h3 id="多个锁就是异步执行"><a href="#多个锁就是异步执行" class="headerlink" title="多个锁就是异步执行"></a>多个锁就是异步执行</h3><p>将上面service类中代码改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsernamePassword</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">anyString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (anyString) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;在&quot;</span> + Instant.now() + <span class="string">&quot;进入同步块&quot;</span>);</span><br><span class="line">usernameParam = username;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">passwordParam = password;</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;在&quot;</span> + Instant.now() + <span class="string">&quot;离开同步块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果就会产生异步效果：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224115509481.png" alt="image-20230224115509481"></p><blockquote><p>同步代码块放在非同步synchronized方法中进行声明，并不能保证调用方法的线程的执行同步/顺序性，即线程调用方法是无序的。</p></blockquote><h2 id="静态同步：synchronized方法与synchronized-class-代码块"><a href="#静态同步：synchronized方法与synchronized-class-代码块" class="headerlink" title="静态同步：synchronized方法与synchronized(class)代码块"></a>静态同步：synchronized方法与synchronized(class)代码块</h2><p>如果synchronized关键字应用在静态方法上，就是对当前*.Java文件对应的Class类的对象进行持锁，Class类的对象是单例的，更具体地说，在静态方法上使用synchronized关键字声明同步方法时，是使用当前静态方法所在类对应Class类的单例对象作为锁的。</p><p>创建类文件Service:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;进入printA&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;在&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;离开printA&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span></span><br><span class="line">+ System.currentTimeMillis() + <span class="string">&quot;进入printB&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;线程名称为：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;在&quot;</span></span><br><span class="line">+ System.currentTimeMillis() + <span class="string">&quot;离开printB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看见加synchronized的方法为静态方法</p></blockquote><p>创建自定义线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">Service.printA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建自定义线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">Service.printB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建启动类Run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line">b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">b.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224142321210.png" alt="image-20230224142321210"></p><p>synchronized关键字加到static静态方法上是将Class类的对象作为锁，而synchronized关键字加 </p><p>到非static静态方法上是将方法所在类的对象作为锁。</p><h2 id="String常量池特性与同步问题"><a href="#String常量池特性与同步问题" class="headerlink" title="String常量池特性与同步问题"></a>String常量池特性与同步问题</h2><p>JVM具有String常量池的功能，所以以下运行结果为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224144815127.png" alt="image-20230224144815127"></p><p>在将synchronized(string)同步块与String联合使用时，要注意常量池可能会出现意外。</p><p>创建类Service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String stringParam)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (stringParam) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.print(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建线程类ThreadB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Service service;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">service.print(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类Run:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>(service);</span><br><span class="line">a.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line"><span class="type">ThreadB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>(service);</span><br><span class="line">b.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">b.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224145621219.png" alt="image-20230224145621219"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因为String的值都是”AA“，所以两个线程持有相同的锁，导致A线程执行中，B线程不能执行，这就是string常量池所带来的问题，所以一般来说同步synchronized代码块都不使用String作为锁对象。</p><h2 id="多线程的死锁"><a href="#多线程的死锁" class="headerlink" title="多线程的死锁"></a>多线程的死锁</h2><p>不同的线程都在等待无法被释放的锁，导致所有的任务都无法继续完成。</p><p>创建类DealThread：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DealThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String username;</span><br><span class="line"><span class="keyword">public</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(String username)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (username.equals(<span class="string">&quot;a&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;按lock1-&gt;lock2代码顺序执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (username.equals(<span class="string">&quot;b&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;按lock2-&gt;lock1代码顺序执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建运行类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">DealThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DealThread</span>();</span><br><span class="line">t1.setFlag(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t1);</span><br><span class="line">thread1.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">t1.setFlag(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t1);</span><br><span class="line">thread2.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224151418495.png" alt="image-20230224151418495"></p><p>查看线程是否有死锁现象：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224151700212.png" alt="image-20230224151700212"></p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224151719796.png" alt="image-20230224151719796"></p><p>可以发现两个线程都被阻塞。死锁是程序设计的bug，在设计程序时就要避免双方互相持有对方的锁，只要互相等待释放锁，就有可能出现死锁。</p><h2 id="holdsLock-Object-obj-方法的使用"><a href="#holdsLock-Object-obj-方法的使用" class="headerlink" title="holdsLock(Object obj)方法的使用"></a>holdsLock(Object obj)方法的使用</h2><p>当且仅当当前线程持有指定对象上的监视器锁时才返回true，此方法旨在允许程序断言当前线程已持有指定的锁。</p><p>创建类Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuhaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/24 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A  &quot;</span>+Thread.holdsLock(Test.class));</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B  &quot;</span>+Thread.holdsLock(Test.class));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;C  &quot;</span>+Thread.holdsLock(Test.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/image-20230224154448010.png" alt="image-20230224154448010"></p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>被synchronized包围的代码称为临界区（Critical Section），临界区中的代码通常是操作共享的数据。临界区就是被同步执行的代码区域，临界区中的代码具有原子性，不可分割，不可被中断。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuhaodong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/24 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//临界区开始</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">criticalSection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//代码1</span></span><br><span class="line">        <span class="comment">//代码2</span></span><br><span class="line">        <span class="comment">//代码3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//临界区结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul><li>可见性：B线程能马上看到A线程更改的数据。</li><li>原子性：原子性是指一组操作在执行时不能被打断。如果在中间执行其他操作会导致这一组操作不连续，获得错误的结果，即非原子性。</li><li>禁止代码重排序</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>当想实现一个变量的值被更改，而其他线程能取到最新的值时，就要对变量使用volatile</li><li>如果多个线程对同一个对象中的同一个实例变量进行写操作，为了避免出现非线程安全问题，就要使用synchronized。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程的目标</title>
      <link href="/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9B%AE%E6%A0%87/"/>
      <url>/2023/02/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9B%AE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程编程的目标"><a href="#多线程编程的目标" class="headerlink" title="多线程编程的目标"></a>多线程编程的目标</h1><ul><li>串行：依次做完每件事。</li><li>并发：一个人同时做多件事。</li><li>并行：并发的极致，三个人同时做三件事。</li></ul><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>一个类在单线程环境下运行正常，在多线程环境下也能正常运行，那么称其是线程安全的。</p><h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><p>不可分割。在读、写某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，不能看见其中间效果。</p><blockquote><p>原子操作时针对访问共享变量的操作而言的，局部变量访问无所谓是否设计原子操作。</p></blockquote><h4 id="保证方式："><a href="#保证方式：" class="headerlink" title="保证方式："></a>保证方式：</h4><ul><li>使用锁（LOCK）。锁具有排他性，能够保障一个共享变量在任意时刻只能够被一个线程访问，消除竞态。</li><li>利用处理器提供的CAS（compare and Swap）指令，CAS指令实现原子性的方式与锁实现原子性的实质是相同的，差别在于锁通常是在软件层次实现，而CAS是在硬件层次，也被看作“硬件锁”。</li></ul><p>在Java语言中，除long型和double型以外的基础类型变量的写操作都是原子操作，这点由Java语言规范（JTS，Java Languange Specification）规定，由Java虚拟机具体实现。</p><p>在多个线程并发访问同一long/double型变量时，可以使用volatile关键字修饰。</p><p>原子操作+原子操作得到的复合操作并不是原子操作。</p><h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h3><p>在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，这就是线程的可见性。</p><h4 id="造成原因："><a href="#造成原因：" class="headerlink" title="造成原因："></a>造成原因：</h4><p>程序中变量可能被分配到寄存器，而不是主存中进行存储，两个线程分别运行在不同处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储，就会产生可见性问题。即便共享变量分配到主存中，也无法保证可见性，因为处理器对主存的访问不是直接的，而是通过高速缓存(Cache)子系统进行的。而一个处理器上运行的线程对变量的更新可能只是更新到写缓存器（Store Buffer）中，还没有到达高速缓冲甚至主存。而另一个处理器的写缓冲器的内容无法被另外一个处理器读取，因此运行在另外一个处理器的线程无法看到这个共享变量的更新。</p><h4 id="保证方式：-1"><a href="#保证方式：-1" class="headerlink" title="保证方式："></a>保证方式：</h4><p>使用volatile关键字，提示JIT编译器被修饰的变量被多个线程共享，阻止JIT编译器做出可能导致程序运行不正常的优化。读取volatile关键字修饰的变量会使相应的处理器执行刷新处理器缓存的动作，从而保障可见性。</p><h3 id="有序性："><a href="#有序性：" class="headerlink" title="有序性："></a>有序性：</h3><p>无论什么情况下一个处理器执行一个线程所执行的内存访问操作在另外一个线程看来都是乱序的，即内存访问操作的顺序看起来像是发生了变化。</p><h4 id="重排序："><a href="#重排序：" class="headerlink" title="重排序："></a>重排序：</h4><p>编译器可能改变两个操作的先后顺序，处理器可能不是完全依照程序的模板代码所指定的顺序执行指令；一个处理器上所执行的多个操作，从其他处理器的角度来看其顺序可能与目标代码所指定的顺序不一致，这种现象叫作重排序。</p><p>重排序是对内存访问有关操作所做的一种优化，可以在不影响单线程程序正确性的情况下提升程序的性能。但是会对多线程的正确性产生影响。</p><h6 id="可能产生来源："><a href="#可能产生来源：" class="headerlink" title="可能产生来源："></a>可能产生来源：</h6><ul><li>源代码顺序：源代码中所指定的内存访问操作顺序。</li><li>程序顺序：在给定处理器上运行的目标代码所指定操作内存的顺序。</li><li>执行顺序：内存访问操作在给定处理器上的实际执行顺序。</li><li>感知顺序：给定处理器所感知到的该处理器及其他处理器内存访问操作发生的顺序。</li></ul><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>Java平台几乎不会执行指令重排序，在其他编译型语言（如C++）可能会。</p><blockquote><p>Java平台包含两种编译器：静态编译器：javac；动态编译器：JIT编译器。前者是将java源代码.java文件编译成字节码.class文件；后者是将字节码动态编译为Java虚拟机宿主机的本地代码（机器码），它是在Java程序运行过程中介入的。</p></blockquote><h4 id="存储子系统重排序"><a href="#存储子系统重排序" class="headerlink" title="存储子系统重排序"></a>存储子系统重排序</h4><p>处理器不是直接访问主内存，而是通过高速缓存，现代处理器还引入了缓冲器以提高高速缓存操作的效率，我们将写缓冲器和高速缓存统称为存储子系统。</p><p>即使在处理器严格依照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下其他处理器对这两个操作的感知顺序依然可能与程序顺序不一致，这种现象就是存储子系统重排序，也被称为内存重排序。</p><p>指令重排序的对象是指令，它是对指令的顺序进行调整，而存储子系统重排序是一种现象而不是一种动作，它没有真正对指令顺序进行过调整，而只是造成了一种指令执行顺序像是被调整过一样的现象。</p><h4 id="貌似串行语义"><a href="#貌似串行语义" class="headerlink" title="貌似串行语义"></a>貌似串行语义</h4><p>重排序不是随意对指令、内存操作的结果进行杂乱无章的排序或者顺序调整，而是遵循一定规则。它会从单线程程序的角度保证重排序后的运行结果不会影响程序的正确性，并不能保证多线程环境下程序的正确性。</p><h4 id="保证内存访问的顺序性"><a href="#保证内存访问的顺序性" class="headerlink" title="保证内存访问的顺序性"></a>保证内存访问的顺序性</h4><p>通过禁止重排序是通过调用处理器提供相应的指令（内存屏障）来实现的。可以使用volatile关键字，synchronized关键字来实现。</p><blockquote><p>可见性是有序性的基础。有序性影响可见性。</p></blockquote><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>一个处理器在同时间段内运行多个线程。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>从Java角度看，一个线程的生命周期状态在RUNNABLE状态与非RUNNABLE状态（包括BLOCKED,WAITING,TIMED和TIMED_WAITING）之间切换的过程就是一个上下文切换的过程。</p><p>一个线程在其运行过程中执行下列任意一个方法都会引起自发性上下文切换</p><ul><li>Threa.sleep(Long millis)</li><li>Obhect.wait()/wait(long timeout)/wait(long timeout,int nanos)</li><li>Thread.yield()</li><li>Thread.join()/Thread.join(long timeout)</li><li>LockSupport.park()</li></ul><p>线程发起I/O操作或等待其他线程所持有的锁也会导致自发性上下文切换。</p><h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><ul><li>时间开销</li><li>线程调度器进行线程调度的开销</li><li>处理器高速缓存重新加载的开销</li><li>上下文切换也可能导致整个一级高速缓存中的内容被冲刷，即一级高速缓存中的内容会被写入下一级高速缓存或主内存中。</li></ul><h3 id="线程的活性故障"><a href="#线程的活性故障" class="headerlink" title="线程的活性故障"></a>线程的活性故障</h3><p>由资源稀缺性或者程序自身的问题和缺陷导致线程一只处于非RUNNABLE状态，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象被称为线程活性障碍。</p><p>常见的活性障碍：</p><ul><li>死锁（DeadLock）：”鹬蚌相争“，一个线程X持有资源A的时候等待另一个线程释放资源B，而另外一个线程Y在持有资源B的时候却等待X释放A。</li><li>锁死（Lockout）：睡美人得到王子的亲吻才会苏醒，但是王子挂了。</li><li>活锁（Livelock）：小猫想抓住自己的尾巴，始终无法追到。</li><li>饥饿（Starvation）：母鸟给瘦弱的小鸟喂食，但是每次都被强壮的小鸟抢走，导致瘦弱的鸟饥饿。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程的安全性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>进程是程序运行的实例，如运行一个Java程序的实质就是启动一个Java虚拟机进程。进程是程序向操作系统申请资源的基本单位。</p><p>线程是进程可执行的最小单位。一个进程可以包含多个线程，一个进程中的所有线程共享该进程中的资源，如内存空间，文件句柄。</p><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><p>Java标准类库java.lang.Thead就是Java平台对线程的实现。Thread类或其子类的实例就是一个线程。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>运行一个线程实际上就是让Java虚拟机执行该线程的run方法，而启动一个线程的方法是Tread类的start方法。启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器Scheduler决定的。start方法调用结束并不意味相应线程已经开始运行，这个线程可能稍后才被运行，甚至也可能永远不会被运行。</p><p>Java语言创建线程有四种方式。第一种是通过Thread类无参构造器Thread()：定义Thread类的子类，在该子类中覆盖run方法并实现线程处理逻辑；第二种种是第二个构造器Thread(Runnable targe)：创建一个java.lang.Runnable接口的实例，并且在该实例的run方法实现处理逻辑，然后以该Runnable接口实例作为构造器的参数直接new一个Thread类的实例；第三种是通过ExecutorService和Callable<Class>实现有返回值的线程；第四种是基于线程池。</Class></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure><p>Threa类实现了Runnable接口。</p></blockquote><p><img src="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230303143814315.png" alt="image-20230303143814315"></p><h5 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CreateThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>start()方法是一个native方法。</p></blockquote><h5 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个线程！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CreateThread</span> <span class="variable">createThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateThread</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(createThread,<span class="string">&quot;线程名称&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实现Runnable的线程实例target作为参数传入Thread后，Thread的run方法在执行时就会调用target.run方法并执行该线程具体的实现逻辑。JDK源码如下</p><p><img src="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230303144417298.png" alt="image-20230303144417298"></p></blockquote><p>一旦现成的run方法执行结束，相应线程的运行也就结束了。并且无法通过重新调用一个已经运行结束的start方法使其重新运行。start方法只能够调用一次，多次调用将抛出异常：IllegalThreadStateException。</p><h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><p>通过ExecutorService和Callable<Class>实现有返回值的线程，创建一个类并实现Callable接口，在call方法中实现具体的运算逻辑并返回计算结果。</Class></p><p>具体的调用过程为：创建一个线程池，一个用于接收返回结果的Future List及Callable线程实例，使用线程池提交任务并将线程执行之后的结果保存在Future中，在线程执行结束后遍历Future List中的Future对象，在该对象上调用get方法就可以获取Callable线程任务返回的数据并汇总结果。实现如下：</p><p><img src="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230303153333773.png" alt="image-20230303153333773"></p><p><img src="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230303153352249.png" alt="image-20230303153352249"></p><h5 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h5><p>基于线程池。</p><p><img src="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/image-20230303154657538.png" alt="image-20230303154657538"></p><h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><div class="table-container"><table><thead><tr><th>属性</th><th>属性类型及用途</th><th>只读属性</th><th>重要事项</th></tr></thead><tbody><tr><td>编号ID</td><td>long型，区别不同线程</td><td>是</td><td>线程结束后，之前的编号可以被后面的线程所使用，因此不适合作为某种唯一标识</td></tr><tr><td>名称Name</td><td>Strign型，主要给人看区别线程，默认格式为：Thread-编号</td><td>否</td><td>设置名称有助于代码调试与定位，名称可以设置为相同</td></tr><tr><td>类别Daemon</td><td>boolean型，为true是该线程为守护线程，否则为用户线程。默认值与父线程相同</td><td>否</td><td>必须在启动前设置，即调用start方法前</td></tr><tr><td>优先级Priority</td><td>int型，用于给线程调度器提示，默认值为5</td><td>否</td><td>不恰当设置可能导致严重问题，如线程饥饿</td></tr></tbody></table></div><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>currentThread()</td><td>返回当前线程，即当前代码的执行线程对象</td><td>同一段代码调用返回值可能对应不同线程对象</td></tr><tr><td>run()</td><td>实现线程任务处理逻辑</td><td>该方法有java虚拟机直接调用，应用程序一般不应调用</td></tr><tr><td>start()</td><td>启动相应线程</td><td>返回不代表线程已经启动，重复调用会抛出异常</td></tr><tr><td>join()</td><td>等待响应线程运行结束</td><td>线程A调用线程B的join方法，线程A的运行会被暂停，直到线程B的运行结束</td></tr><tr><td>yield()</td><td>使线程主动放弃对CPU的展占用，可能导致当前线程被暂停</td><td>该方法不可靠，线程被调用时仍可能继续运行</td></tr><tr><td>sleep(long millis)</td><td>使当前线程休眠指定的时间</td></tr></tbody></table></div><h3 id="线程的层次关系"><a href="#线程的层次关系" class="headerlink" title="线程的层次关系"></a>线程的层次关系</h3><h4 id="父子关系："><a href="#父子关系：" class="headerlink" title="父子关系："></a>父子关系：</h4><p>子线程1创建了子线程11，那么子线程11线程为子线程1的子线程，子线程1为线程11的父线程。</p><p><img src="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/线程层级关系.png" alt="线程生命周期"></p><h3 id="线程的生命周期状态"><a href="#线程的生命周期状态" class="headerlink" title="线程的生命周期状态"></a>线程的生命周期状态</h3><p><img src="/2023/02/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/线程生命周期.png" alt="线程生命周期"></p><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>Java线程的状态可以使用监控工具查看，也可以通过Thread.getState()调用来获取。</p><ul><li><p>NEW：已创建而未启动，因为一个线程只能被创建一次，因此一个线程也只能有一次处于该状态。</p></li><li><p>RUNNABLE：该状态为复合态，它包含READY和RUNNING。处于READY状态的线程被称为活跃线程。</p></li><li>BLOCKED：一个线程发起一个阻塞式I/O操作，或申请一个由其他线程持有的独占资源（锁）时，相应的线程会处于该状态。</li><li>WAITING：一个线程执行某种特定方法之后就会处于这种等待其他线程执行另外一些操作的状态。</li><li>TIMED_WAITING：和WAITING类似，这个是处于哟时间的等待。</li><li>TERMINATED：已经执行结束的线程处于该状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Gallery</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
